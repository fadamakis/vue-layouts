{
  "status": "ok",
  "feed": {
      "url": "https://medium.com/feed/@fadamakis",
      "title": "Stories by Fotis Adamakis on Medium",
      "link": "https://medium.com/@fadamakis?source=rss-ba9bef041285------2",
      "author": "",
      "description": "Stories by Fotis Adamakis on Medium",
      "image": "https://cdn-images-1.medium.com/fit/c/150/150/1*j7QGVGcLpSRLdgyQC7P_1A.jpeg"
  },
  "items": [
      {
          "title": "Radix-Vue: The Next Generation Component Library for Vue",
          "pubDate": "2023-08-06 09:18:19",
          "link": "https://fadamakis.medium.com/radix-vue-the-next-generation-component-library-for-vue-29b20fcfd4ed?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/29b20fcfd4ed",
          "author": "Fotis Adamakis",
          "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*EnF7bFHtdHXAx2pzcnp0jw.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*EnF7bFHtdHXAx2pzcnp0jw.png\"></figure><h4>Just Released</h4>\n<p><a href=\"https://www.radix-vue.com/\">Radix-vue</a> is a community-led adaptation of <a href=\"https://www.radix-ui.com/\">Radix UI</a> in the Vue ecosystem. It prioritizes <strong>accessibility</strong>, <strong>customization</strong>, and <strong>developer experience</strong> with a variety of <strong>unstyled</strong> and <strong>accessible</strong> components. It is inspired by the rise of the headless component libraries that decouple the UI from the component library itself. Let's explore all the benefits when doing\u00a0so.</p>\n<h3>Headless Component Libraries</h3>\n<p>Everyone shares similar definitions for common UI patterns, such as accordions, checkboxes, dropdowns, sliders, and tooltips. These UI patterns are documented by <a href=\"https://www.w3.org/WAI/ARIA/apg/#aria_ex\">WAI-ARIA</a> and are generally understood by the community. However, the implementations and the examples provided are either nonexistent, lack functionality, or cannot be customized sufficiently.</p>\n<p>As a result, we are forced to build custom components, which is an incredibly difficult task. This means that most components on the web are inaccessible, non-performant, and lack important features.</p>\n<p>The goal of a headless component library like Radix is to provide a low-level implementation of all these components and enable a codebase to create a design system by only implementing the styles to match the required\u00a0designs.</p>\n<p>The components of a headless UI library\u00a0are:</p>\n<ul>\n<li>\n<strong>Unstyled: </strong>Everything is shipped with zero styles, giving you complete control over\u00a0styling.</li>\n<li>\n<strong>Accessible: </strong>Components adhere to the WAI-ARIA design patterns.</li>\n<li>\n<strong>Modular: </strong>Each component can be installed individually so you can adopt them incrementally.</li>\n<li>\n<strong>Encapsulated</strong>: All of the behaviour is handled internally, so you can get up and running as smoothly as possible, without needing to create any local\u00a0states.</li>\n</ul>\n<h4>Demo</h4>\n<p>For demonstrating the library we will use a modal dialog, which is often styled and behave very differently across applications.</p>\n<p>Starting with a new project, first, we need to install the library from npm\u00a0using:</p>\n<pre>npm install radix-vue </pre>\n<p>Then we need to read the <a href=\"https://www.radix-vue.com/components/dialog.html#dialog\">component documentation</a>. The anatomy and the API reference can give us an overview and they are accompanied by many useful examples.</p>\n<pre>// Anatomy of the modal dialog component<br>&lt;script setup&gt;<br>import {<br>  DialogRoot,<br>  DialogTrigger,<br>  DialogContent,<br>  DialogOverlay,<br>  DialogClose,<br>  DialogPortal,<br>  DialogTitle,<br>  DialogDescription,<br>} from \"radix-vue\";<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;DialogRoot&gt;<br>    &lt;DialogTrigger /&gt;<br>    &lt;DialogPortal&gt;<br>      &lt;DialogOverlay /&gt;<br>      &lt;DialogContent&gt;<br>        &lt;DialogTitle /&gt;<br>        &lt;DialogDescription /&gt;<br>        &lt;DialogClose /&gt;<br>      &lt;/DialogContent&gt;<br>    &lt;/DialogPortal&gt;<br>  &lt;/DialogRoot&gt;<br>&lt;/template&gt; </pre>\n<p>Let's start with a simple example. A dialog with a title and description.</p>\n<pre>&lt;script setup&gt;<br>import { ref } from \"vue\";<br>import { DialogRoot, DialogTrigger, DialogContent, DialogOverlay, DialogPortal, DialogTitle, DialogDescription, DialogClose } from \"radix-vue\";<br><br>const open = ref(false);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br> &lt;DialogRoot v-model:open=\"open\"&gt;<br>  &lt;DialogTrigger&gt;Open&lt;/DialogTrigger&gt;<br>  &lt;DialogPortal&gt;<br>   &lt;DialogOverlay /&gt;<br>   &lt;DialogContent&gt;<br>    &lt;DialogTitle&gt;Title&lt;/DialogTitle&gt;<br>    &lt;DialogDescription&gt;Description&lt;/DialogDescription&gt;<br>    &lt;DialogClose&gt;Close&lt;/DialogClose&gt;<br>   &lt;/DialogContent&gt;<br>  &lt;/DialogPortal&gt;<br> &lt;/DialogRoot&gt;<br>&lt;/template&gt;</pre>\n<p>Will produce the following</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/468/1*tyXlN53S2_24h5WPSwTTYA.gif\"></figure><p>OK, the result is anticlimactic but as advertised the styling is not a concern of a headless UI library. It is up to us to provide them according to our style\u00a0guide.</p>\n<p>As a reference, we will use the following design.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/459/1*5ZuqcBD6xPxqI7dzqh46PA.png\"></figure><p>In order to style it we will add classes and target them with some basic\u00a0CSS.</p>\n<pre>&lt;script setup&gt;<br>import { ref } from \"vue\";<br>import {<br>  DialogRoot,<br>  DialogTrigger,<br>  DialogContent,<br>  DialogOverlay,<br>  DialogPortal,<br>  DialogTitle,<br>  DialogDescription,<br>  DialogClose,<br>} from \"radix-vue\";<br><br>const open = ref(false);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;DialogRoot v-model:open=\"open\"&gt;<br>    &lt;DialogTrigger class=\"dialog-trigger\"&gt;Open Modal Dialog&lt;/DialogTrigger&gt;<br>    &lt;DialogPortal&gt;<br>      &lt;DialogOverlay class=\"dialog-overlay\" /&gt;<br>      &lt;DialogContent class=\"dialog-content\"&gt;<br>        &lt;img class=\"dialog-image\" src=\"./assets/feedback.png\" /&gt;<br>        &lt;DialogTitle class=\"dialog-title\"&gt;Provide Feedback&lt;/DialogTitle&gt;<br>        &lt;DialogDescription class=\"dialog-description\"&gt;<br>          We appreciate your feedback. Please take a few minutes to let us know what you<br>          think of our product.<br>        &lt;/DialogDescription&gt;<br>        &lt;div class=\"button-group\"&gt;<br>          &lt;DialogClose class=\"cta\"&gt;Give Feedback&lt;/DialogClose&gt;<br>          &lt;DialogClose&gt;Cancel&lt;/DialogClose&gt;<br>        &lt;/div&gt;<br>      &lt;/DialogContent&gt;<br>    &lt;/DialogPortal&gt;<br>  &lt;/DialogRoot&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.dialog-trigger {<br>  margin: 100px auto;<br>}<br><br>.dialog-overlay {<br>  position: fixed;<br>  top: 0;<br>  left: 0;<br>  right: 0;<br>  bottom: 0;<br>  background: rgba(0, 0, 0, 0.5);<br>}<br><br>.dialog-content {<br>  position: fixed;<br>  top: 50%;<br>  left: 50%;<br>  transform: translate(-50%, -50%);<br>  background: #ffffff;<br>  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);<br>  border-radius: 10px;<br>  padding: 20px;<br>  max-width: 400px;<br>}<br><br>.dialog-image {<br>  display: block;<br>  width: 120px;<br>  margin: 0 auto 20px;<br>}<br><br>.dialog-title {<br>  font-size: 22px;<br>  font-weight: 600;<br>  margin: 0 0 10px;<br>}<br><br>.dialog-description {<br>  color: rgb(107, 114, 128);<br>  letter-spacing: 0.4px;<br>  line-height: 1.6;<br>  margin: 0;<br>}<br>&lt;/style&gt;</pre>\n<blockquote>Tip: A library like <a href=\"https://tailwindcss.com/\">Tailwind</a> can be utilised at this stage to minimize written\u00a0styles.</blockquote>\n<p>We managed with <em>little</em> effort to implement a fully functional and keyboard-accessible modal. You can check it out\u00a0<a href=\"https://fadamakis.github.io/vue-radix/\">here</a>.</p>\n<p>The only problem is that our component is not reusable. If we were to create another modal we would have to duplicate all the styles. And code repetition is a sin in software development. In order to avoid this we will create a wrapper (shell) component that will host all of the common styles and functionality and will ensure that all of our modals look and behave the\u00a0same.</p>\n<h4>Reusable Modal Component</h4>\n<p>The goal of the reusable modal dialog component is to serve as a bridge between our application and Radix-vue and narrow down all the possible options and configurations.</p>\n<p>To do this we will replace the component-specific parts with <a href=\"https://vuejs.org/guide/components/slots.html#named-slots\">named\u00a0slots</a>.</p>\n<p><em>@/components/common/AppModal.vue</em></p>\n<pre>&lt;script setup&gt;<br>import { ref } from \"vue\";<br>import {<br>  DialogRoot,<br>  DialogTrigger,<br>  DialogContent,<br>  DialogOverlay,<br>  DialogPortal,<br>  DialogTitle,<br>  DialogDescription,<br>  DialogClose,<br>} from \"radix-vue\";<br><br>const open = ref(true);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;DialogRoot v-model:open=\"open\"&gt;<br>    &lt;DialogTrigger class=\"dialog-trigger\"&gt;<br>      &lt;slot name=\"trigger\" /&gt;<br>    &lt;/DialogTrigger&gt;<br>    &lt;DialogPortal&gt;<br>      &lt;DialogOverlay class=\"dialog-overlay\" /&gt;<br>      &lt;DialogContent class=\"dialog-content\"&gt;<br>        &lt;div class=\"dialog-image\"&gt;<br>          &lt;slot name=\"image\" /&gt;<br>        &lt;/div&gt;<br>        &lt;DialogTitle class=\"dialog-title\"&gt;<br>          &lt;slot name=\"title\" /&gt;<br>        &lt;/DialogTitle&gt;<br>        &lt;DialogDescription class=\"dialog-description\"&gt;<br>          &lt;slot name=\"description\" /&gt;<br>        &lt;/DialogDescription&gt;<br>        &lt;div class=\"button-group\"&gt;<br>        &lt;div class=\"cta\"&gt;<br>          &lt;slot name=\"cta\" /&gt;<br>        &lt;/div&gt;<br>          &lt;DialogClose&gt;Cancel&lt;/DialogClose&gt;<br>        &lt;/div&gt;<br>      &lt;/DialogContent&gt;<br>    &lt;/DialogPortal&gt;<br>  &lt;/DialogRoot&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.dialog-trigger {<br>  margin: 100px auto;<br>}<br><br>.dialog-overlay {<br>  position: fixed;<br>  top: 0;<br>  left: 0;<br>  right: 0;<br>  bottom: 0;<br>  background: rgba(0, 0, 0, 0.5);<br>}<br><br>.dialog-content {<br>  position: fixed;<br>  top: 50%;<br>  left: 50%;<br>  transform: translate(-50%, -50%);<br>  background: #ffffff;<br>  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);<br>  border-radius: 10px;<br>  padding: 20px;<br>  max-width: 400px;<br>}<br><br>.dialog-image :deep(img){<br>  display: block;<br>  width: 120px;<br>  margin: 0 auto 20px;<br>}<br><br>.dialog-title {<br>  font-size: 22px;<br>  font-weight: 600;<br>  margin: 0 0 10px;<br>}<br><br>.dialog-description {<br>  color: rgb(107, 114, 128);<br>  letter-spacing: 0.4px;<br>  line-height: 1.6;<br>  margin: 0;<br>}<br>&lt;/style&gt;</pre>\n<p>In our application, we just have to fill the required slots and implement any required\u00a0logic.</p>\n<p><em>@/components/FeedbackModal.vue</em></p>\n<pre>&lt;script setup&gt;<br>import AppModal from \"./common/AppModal.vue\";<br><br>function handleFeedback() {<br>  // TODO: Handle feedback modal specific logic<br>}<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;AppModal&gt;<br>    &lt;template #trigger&gt;Open Dialog Modal&lt;/template&gt;<br>    &lt;template #image&gt;<br>      &lt;img src=\"./../assets/feedback.png\" alt=\"\" /&gt;<br>    &lt;/template&gt;<br>    &lt;template #title&gt;Provide Feedback&lt;/template&gt;<br>    &lt;template #description&gt;<br>      We appreciate your feedback. Please take a few minutes to let us know what you think<br>      of our product.<br>    &lt;/template&gt;<br>    &lt;template #cta&gt;<br>      &lt;button @click=\"handleFeedback\"&gt;Give Feedback&lt;/button&gt;<br>    &lt;/template&gt;<br>  &lt;/AppModal&gt;<br>&lt;/template&gt;</pre>\n<p>Additionally adding modifiers like modal size, close button etc can now be implemented inside the AppModal and be controlled by\u00a0props.</p>\n<pre>&lt;script setup&gt;<br>...<br>defineProps({<br>  size: {<br>    type: string,<br>    default: \"md\",<br>  },<br>  hasCloseButton: {<br>    type: boolean,<br>  },<br>});<br>...<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>...<br>  &lt;DialogClose v-if=\"hasCloseButton\" /&gt;<br>...<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>...<br>.dialog-content.sm {<br>    max-width: 300px;<br>}<br><br>.dialog-content.md {<br>    max-width: 400px;<br>}<br><br>.dialog-content.lg {<br>    max-width: 500px;<br>}<br>...<br>&lt;/style&gt;</pre>\n<pre>&lt;AppModal size=\"sm\" has-close-button&gt;<br>    ...<br>&lt;/AppModal&gt;</pre>\n<h3>Conclusion</h3>\n<p>Headless UI libraries are getting a lot of traction because they offer a number of advantages over traditional UI libraries. They give us complete control over the look and feel of our application, are often more lightweight and accessible, can be reused across multiple projects, and are easier to maintain.</p>\n<p>On an enterprise codebase where following the company brand is crucial, they can power a full fledge design system. The built-in accessibility comes for free and can have a big impact on popular applications.</p>\n<p>It's refreshing to see the UI component library landscape in the Vue ecosystem looking promising for a change.\u00a0\ud83d\ude80</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/131/1*Cq1aKyuOPDBErrfZDfz0lQ@2x.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=29b20fcfd4ed\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*EnF7bFHtdHXAx2pzcnp0jw.png\"></figure><h4>Just Released</h4>\n<p><a href=\"https://www.radix-vue.com/\">Radix-vue</a> is a community-led adaptation of <a href=\"https://www.radix-ui.com/\">Radix UI</a> in the Vue ecosystem. It prioritizes <strong>accessibility</strong>, <strong>customization</strong>, and <strong>developer experience</strong> with a variety of <strong>unstyled</strong> and <strong>accessible</strong> components. It is inspired by the rise of the headless component libraries that decouple the UI from the component library itself. Let's explore all the benefits when doing\u00a0so.</p>\n<h3>Headless Component Libraries</h3>\n<p>Everyone shares similar definitions for common UI patterns, such as accordions, checkboxes, dropdowns, sliders, and tooltips. These UI patterns are documented by <a href=\"https://www.w3.org/WAI/ARIA/apg/#aria_ex\">WAI-ARIA</a> and are generally understood by the community. However, the implementations and the examples provided are either nonexistent, lack functionality, or cannot be customized sufficiently.</p>\n<p>As a result, we are forced to build custom components, which is an incredibly difficult task. This means that most components on the web are inaccessible, non-performant, and lack important features.</p>\n<p>The goal of a headless component library like Radix is to provide a low-level implementation of all these components and enable a codebase to create a design system by only implementing the styles to match the required\u00a0designs.</p>\n<p>The components of a headless UI library\u00a0are:</p>\n<ul>\n<li>\n<strong>Unstyled: </strong>Everything is shipped with zero styles, giving you complete control over\u00a0styling.</li>\n<li>\n<strong>Accessible: </strong>Components adhere to the WAI-ARIA design patterns.</li>\n<li>\n<strong>Modular: </strong>Each component can be installed individually so you can adopt them incrementally.</li>\n<li>\n<strong>Encapsulated</strong>: All of the behaviour is handled internally, so you can get up and running as smoothly as possible, without needing to create any local\u00a0states.</li>\n</ul>\n<h4>Demo</h4>\n<p>For demonstrating the library we will use a modal dialog, which is often styled and behave very differently across applications.</p>\n<p>Starting with a new project, first, we need to install the library from npm\u00a0using:</p>\n<pre>npm install radix-vue </pre>\n<p>Then we need to read the <a href=\"https://www.radix-vue.com/components/dialog.html#dialog\">component documentation</a>. The anatomy and the API reference can give us an overview and they are accompanied by many useful examples.</p>\n<pre>// Anatomy of the modal dialog component<br>&lt;script setup&gt;<br>import {<br>  DialogRoot,<br>  DialogTrigger,<br>  DialogContent,<br>  DialogOverlay,<br>  DialogClose,<br>  DialogPortal,<br>  DialogTitle,<br>  DialogDescription,<br>} from \"radix-vue\";<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;DialogRoot&gt;<br>    &lt;DialogTrigger /&gt;<br>    &lt;DialogPortal&gt;<br>      &lt;DialogOverlay /&gt;<br>      &lt;DialogContent&gt;<br>        &lt;DialogTitle /&gt;<br>        &lt;DialogDescription /&gt;<br>        &lt;DialogClose /&gt;<br>      &lt;/DialogContent&gt;<br>    &lt;/DialogPortal&gt;<br>  &lt;/DialogRoot&gt;<br>&lt;/template&gt; </pre>\n<p>Let's start with a simple example. A dialog with a title and description.</p>\n<pre>&lt;script setup&gt;<br>import { ref } from \"vue\";<br>import { DialogRoot, DialogTrigger, DialogContent, DialogOverlay, DialogPortal, DialogTitle, DialogDescription, DialogClose } from \"radix-vue\";<br><br>const open = ref(false);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br> &lt;DialogRoot v-model:open=\"open\"&gt;<br>  &lt;DialogTrigger&gt;Open&lt;/DialogTrigger&gt;<br>  &lt;DialogPortal&gt;<br>   &lt;DialogOverlay /&gt;<br>   &lt;DialogContent&gt;<br>    &lt;DialogTitle&gt;Title&lt;/DialogTitle&gt;<br>    &lt;DialogDescription&gt;Description&lt;/DialogDescription&gt;<br>    &lt;DialogClose&gt;Close&lt;/DialogClose&gt;<br>   &lt;/DialogContent&gt;<br>  &lt;/DialogPortal&gt;<br> &lt;/DialogRoot&gt;<br>&lt;/template&gt;</pre>\n<p>Will produce the following</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/468/1*tyXlN53S2_24h5WPSwTTYA.gif\"></figure><p>OK, the result is anticlimactic but as advertised the styling is not a concern of a headless UI library. It is up to us to provide them according to our style\u00a0guide.</p>\n<p>As a reference, we will use the following design.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/459/1*5ZuqcBD6xPxqI7dzqh46PA.png\"></figure><p>In order to style it we will add classes and target them with some basic\u00a0CSS.</p>\n<pre>&lt;script setup&gt;<br>import { ref } from \"vue\";<br>import {<br>  DialogRoot,<br>  DialogTrigger,<br>  DialogContent,<br>  DialogOverlay,<br>  DialogPortal,<br>  DialogTitle,<br>  DialogDescription,<br>  DialogClose,<br>} from \"radix-vue\";<br><br>const open = ref(false);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;DialogRoot v-model:open=\"open\"&gt;<br>    &lt;DialogTrigger class=\"dialog-trigger\"&gt;Open Modal Dialog&lt;/DialogTrigger&gt;<br>    &lt;DialogPortal&gt;<br>      &lt;DialogOverlay class=\"dialog-overlay\" /&gt;<br>      &lt;DialogContent class=\"dialog-content\"&gt;<br>        &lt;img class=\"dialog-image\" src=\"./assets/feedback.png\" /&gt;<br>        &lt;DialogTitle class=\"dialog-title\"&gt;Provide Feedback&lt;/DialogTitle&gt;<br>        &lt;DialogDescription class=\"dialog-description\"&gt;<br>          We appreciate your feedback. Please take a few minutes to let us know what you<br>          think of our product.<br>        &lt;/DialogDescription&gt;<br>        &lt;div class=\"button-group\"&gt;<br>          &lt;DialogClose class=\"cta\"&gt;Give Feedback&lt;/DialogClose&gt;<br>          &lt;DialogClose&gt;Cancel&lt;/DialogClose&gt;<br>        &lt;/div&gt;<br>      &lt;/DialogContent&gt;<br>    &lt;/DialogPortal&gt;<br>  &lt;/DialogRoot&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.dialog-trigger {<br>  margin: 100px auto;<br>}<br><br>.dialog-overlay {<br>  position: fixed;<br>  top: 0;<br>  left: 0;<br>  right: 0;<br>  bottom: 0;<br>  background: rgba(0, 0, 0, 0.5);<br>}<br><br>.dialog-content {<br>  position: fixed;<br>  top: 50%;<br>  left: 50%;<br>  transform: translate(-50%, -50%);<br>  background: #ffffff;<br>  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);<br>  border-radius: 10px;<br>  padding: 20px;<br>  max-width: 400px;<br>}<br><br>.dialog-image {<br>  display: block;<br>  width: 120px;<br>  margin: 0 auto 20px;<br>}<br><br>.dialog-title {<br>  font-size: 22px;<br>  font-weight: 600;<br>  margin: 0 0 10px;<br>}<br><br>.dialog-description {<br>  color: rgb(107, 114, 128);<br>  letter-spacing: 0.4px;<br>  line-height: 1.6;<br>  margin: 0;<br>}<br>&lt;/style&gt;</pre>\n<blockquote>Tip: A library like <a href=\"https://tailwindcss.com/\">Tailwind</a> can be utilised at this stage to minimize written\u00a0styles.</blockquote>\n<p>We managed with <em>little</em> effort to implement a fully functional and keyboard-accessible modal. You can check it out\u00a0<a href=\"https://fadamakis.github.io/vue-radix/\">here</a>.</p>\n<p>The only problem is that our component is not reusable. If we were to create another modal we would have to duplicate all the styles. And code repetition is a sin in software development. In order to avoid this we will create a wrapper (shell) component that will host all of the common styles and functionality and will ensure that all of our modals look and behave the\u00a0same.</p>\n<h4>Reusable Modal Component</h4>\n<p>The goal of the reusable modal dialog component is to serve as a bridge between our application and Radix-vue and narrow down all the possible options and configurations.</p>\n<p>To do this we will replace the component-specific parts with <a href=\"https://vuejs.org/guide/components/slots.html#named-slots\">named\u00a0slots</a>.</p>\n<p><em>@/components/common/AppModal.vue</em></p>\n<pre>&lt;script setup&gt;<br>import { ref } from \"vue\";<br>import {<br>  DialogRoot,<br>  DialogTrigger,<br>  DialogContent,<br>  DialogOverlay,<br>  DialogPortal,<br>  DialogTitle,<br>  DialogDescription,<br>  DialogClose,<br>} from \"radix-vue\";<br><br>const open = ref(true);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;DialogRoot v-model:open=\"open\"&gt;<br>    &lt;DialogTrigger class=\"dialog-trigger\"&gt;<br>      &lt;slot name=\"trigger\" /&gt;<br>    &lt;/DialogTrigger&gt;<br>    &lt;DialogPortal&gt;<br>      &lt;DialogOverlay class=\"dialog-overlay\" /&gt;<br>      &lt;DialogContent class=\"dialog-content\"&gt;<br>        &lt;div class=\"dialog-image\"&gt;<br>          &lt;slot name=\"image\" /&gt;<br>        &lt;/div&gt;<br>        &lt;DialogTitle class=\"dialog-title\"&gt;<br>          &lt;slot name=\"title\" /&gt;<br>        &lt;/DialogTitle&gt;<br>        &lt;DialogDescription class=\"dialog-description\"&gt;<br>          &lt;slot name=\"description\" /&gt;<br>        &lt;/DialogDescription&gt;<br>        &lt;div class=\"button-group\"&gt;<br>        &lt;div class=\"cta\"&gt;<br>          &lt;slot name=\"cta\" /&gt;<br>        &lt;/div&gt;<br>          &lt;DialogClose&gt;Cancel&lt;/DialogClose&gt;<br>        &lt;/div&gt;<br>      &lt;/DialogContent&gt;<br>    &lt;/DialogPortal&gt;<br>  &lt;/DialogRoot&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.dialog-trigger {<br>  margin: 100px auto;<br>}<br><br>.dialog-overlay {<br>  position: fixed;<br>  top: 0;<br>  left: 0;<br>  right: 0;<br>  bottom: 0;<br>  background: rgba(0, 0, 0, 0.5);<br>}<br><br>.dialog-content {<br>  position: fixed;<br>  top: 50%;<br>  left: 50%;<br>  transform: translate(-50%, -50%);<br>  background: #ffffff;<br>  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);<br>  border-radius: 10px;<br>  padding: 20px;<br>  max-width: 400px;<br>}<br><br>.dialog-image :deep(img){<br>  display: block;<br>  width: 120px;<br>  margin: 0 auto 20px;<br>}<br><br>.dialog-title {<br>  font-size: 22px;<br>  font-weight: 600;<br>  margin: 0 0 10px;<br>}<br><br>.dialog-description {<br>  color: rgb(107, 114, 128);<br>  letter-spacing: 0.4px;<br>  line-height: 1.6;<br>  margin: 0;<br>}<br>&lt;/style&gt;</pre>\n<p>In our application, we just have to fill the required slots and implement any required\u00a0logic.</p>\n<p><em>@/components/FeedbackModal.vue</em></p>\n<pre>&lt;script setup&gt;<br>import AppModal from \"./common/AppModal.vue\";<br><br>function handleFeedback() {<br>  // TODO: Handle feedback modal specific logic<br>}<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;AppModal&gt;<br>    &lt;template #trigger&gt;Open Dialog Modal&lt;/template&gt;<br>    &lt;template #image&gt;<br>      &lt;img src=\"./../assets/feedback.png\" alt=\"\" /&gt;<br>    &lt;/template&gt;<br>    &lt;template #title&gt;Provide Feedback&lt;/template&gt;<br>    &lt;template #description&gt;<br>      We appreciate your feedback. Please take a few minutes to let us know what you think<br>      of our product.<br>    &lt;/template&gt;<br>    &lt;template #cta&gt;<br>      &lt;button @click=\"handleFeedback\"&gt;Give Feedback&lt;/button&gt;<br>    &lt;/template&gt;<br>  &lt;/AppModal&gt;<br>&lt;/template&gt;</pre>\n<p>Additionally adding modifiers like modal size, close button etc can now be implemented inside the AppModal and be controlled by\u00a0props.</p>\n<pre>&lt;script setup&gt;<br>...<br>defineProps({<br>  size: {<br>    type: string,<br>    default: \"md\",<br>  },<br>  hasCloseButton: {<br>    type: boolean,<br>  },<br>});<br>...<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>...<br>  &lt;DialogClose v-if=\"hasCloseButton\" /&gt;<br>...<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>...<br>.dialog-content.sm {<br>    max-width: 300px;<br>}<br><br>.dialog-content.md {<br>    max-width: 400px;<br>}<br><br>.dialog-content.lg {<br>    max-width: 500px;<br>}<br>...<br>&lt;/style&gt;</pre>\n<pre>&lt;AppModal size=\"sm\" has-close-button&gt;<br>    ...<br>&lt;/AppModal&gt;</pre>\n<h3>Conclusion</h3>\n<p>Headless UI libraries are getting a lot of traction because they offer a number of advantages over traditional UI libraries. They give us complete control over the look and feel of our application, are often more lightweight and accessible, can be reused across multiple projects, and are easier to maintain.</p>\n<p>On an enterprise codebase where following the company brand is crucial, they can power a full fledge design system. The built-in accessibility comes for free and can have a big impact on popular applications.</p>\n<p>It's refreshing to see the UI component library landscape in the Vue ecosystem looking promising for a change.\u00a0\ud83d\ude80</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/131/1*Cq1aKyuOPDBErrfZDfz0lQ@2x.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=29b20fcfd4ed\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "vue",
              "vuejs",
              "javascript",
              "accessibility",
              "front-end-development"
          ]
      },
      {
          "title": "A Front-End Application Folder Structure that Makes Sense",
          "pubDate": "2023-07-31 17:16:15",
          "link": "https://fadamakis.medium.com/a-front-end-application-folder-structure-that-makes-sense-ecc0b690968b?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/ecc0b690968b",
          "author": "Fotis Adamakis",
          "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*3viiXXIWhBUcEtFXTySzkQ.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3viiXXIWhBUcEtFXTySzkQ.png\"></figure><p>One of the most critical and challenging aspects of a large-scale application is a good and reasonable folder structure. Before considering breaking the codebase into multiple applications using micro frontends there are some steps that can be followed to improve the architecture at a project level and make the transition easier if you ever consider that\u00a0path.</p>\n<p>The goal is to apply some kind of modularisation that will make the codebase easier to understand by setting boundaries between features and minimizing code coupling and side\u00a0effects.</p>\n<h3>Default Project Structure</h3>\n<p>By default when scaffolding a new project using one of the popular front-end frameworks the component structure is flat and follows no hierarchy whatsoever.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*yPId5D9_0q4MZGxfYhI8OQ.png\"></figure><blockquote>This example uses <a href=\"https://github.com/vuejs/create-vue/tree/main/template/code\">Vue default project structure</a> but <a href=\"https://legacy.reactjs.org/docs/faq-structure.html\">React also doesn\u2019t have an opinion on how you put files into\u00a0folders</a>.</blockquote>\n<ul>\n<li>The <strong>assets</strong> directory stores static assets such as images, fonts, and CSS files used throughout the application.</li>\n<li>The <strong>components</strong> directory contains reusable Vue components. A flat hierarchy is recommended.</li>\n<li>The <strong>main.js</strong> file serves as the entry point of your application, enabling Vue initialization and configuration of plugins or additional libraries.</li>\n<li>The <strong>App.vue</strong> file represents the root component of your application, acting as a container for other components and serving as the main template.</li>\n</ul>\n<p>We have seen the hard way that for a large project, this architecture will soon get out of hand. Some kind of modularisation is needed to be able to easily locate a given file, set boundaries between features, and avoid tight coupling of the components.</p>\n<h3>Breaking the Application into Multiple\u00a0Features</h3>\n<p>Any large application is broken into multiple independent features. Identifying them is not always easy and straightforward but it gets better after some time and experience. Let's try to break together a popular application into sections as an exercise.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tjpCnCQGrQPk6pNQsBtUew.png\"></figure><p>Twitter's homepage has a lot going on. The timeline which is the core of the page is surrounded by many features like a navigation, a tweet creation section, a sidebar with multiple sub-components, a floating messages component etc.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/812/1*7cmlPjkBylF2QR_HBxHSyQ.gif\"></figure><p>Having all of the components that make up these features in the same folder is not maintainable and locating one of them would be extremely hard even when using the IDE\u2019s quick find\u00a0option.</p>\n<h3>A More Elaborate Project Structure</h3>\n<p>From experience, a better and more comprehensive file structure looks like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/352/1*B-EQbBPvvZ8S3zov2EK4bg.png\"></figure><ul>\n<li>\n<strong>components</strong>: All shared components that are used across the entire application.</li>\n<li>\n<strong>composables</strong>: All shared composables.</li>\n<li>\n<strong>config</strong>: Application configuration files.</li>\n<li>\n<strong>features</strong>: Contains all the application features. We want to keep most of the application code inside here. More on this\u00a0later.</li>\n<li>\n<strong>layouts</strong>: Different layouts for the\u00a0pages.</li>\n<li>\n<strong>lib</strong>: Configurations for different third-party libraries that are used in our application.</li>\n<li>\n<strong>pages</strong>: The pages of our application.</li>\n<li>\n<strong>services: </strong>Shared application services and providers.</li>\n<li>\n<strong>stores</strong>: Global state\u00a0stores.</li>\n<li>\n<strong>test</strong>: Test-related mocks, helpers, utilities, and configurations.</li>\n<li>\n<strong>types</strong>: Shared TypeScript type definitions.</li>\n<li>\n<strong>utils</strong>: Shared utility functions.</li>\n</ul>\n<blockquote>Run the following command on your project root to create any folder that doesn't exist\u00a0already.</blockquote>\n<pre>mkdir -p src/{composables,layouts,pages,utils,assets,config,lib,services,test,components,features,stores,types}</pre>\n<p>Three important things to\u00a0note:</p>\n<ul>\n<li>The <strong>Pages</strong> folder is already some kind of modularisation by default both in terms of contexts and in actual chunks that a build tool like webpack or Vite will create. Having all the pages in one place is very helpful but the logic inside them should be kept to the\u00a0minimum.</li>\n<li>For easier maintenance and scalability, we aim to keep most of the application code inside the <strong>features</strong> folder. Every feature folder should contain domain-specific code for a given\u00a0feature.</li>\n<li>In a perfect world, we shouldn't have shared components, composables, stores and services and everything would be inside the corresponding feature folder. Unfortunately in real projects, this cannot be avoided but we should plan ahead and be extra careful when adding something to these\u00a0folders.</li>\n</ul>\n<h4>Features Folder</h4>\n<p>As we mentioned earlier, the majority of our application should live inside the features folder split into multiple sub directories.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/727/1*x1p3EkyYXSQ8RmOMcCOBQQ.png\"></figure><ul>\n<li>\n<strong>api</strong>: All the fetch logic goes here. This decouples the API and the\u00a0UI.</li>\n<li>\n<strong>components</strong>: Feature specific components.</li>\n<li>\n<strong>composables</strong>: Feature specific composables.</li>\n<li>\n<strong>stores</strong>: The state management code. Multiple sub-modules are expected and actually encouraged.</li>\n<li>\n<strong>types</strong>: Feature specific typeScript type definitions.</li>\n<li>\n<strong>index.ts</strong>: This is the entry point of the feature. It behaves as the <strong>public API </strong>of the feature, and it should only export things that should be public for other parts of the application.</li>\n</ul>\n<p>The above<strong>index.ts</strong> file serves as the public API of each feature. When importing something from another domain it should be done only through this file. This should prevent circular dependencies, and also make it easier to find the source of an\u00a0import.</p>\n<pre># Bad \ud83d\udeab \ud83d\udeab \ud83d\udeab<br>import { UserProfile } from '@/features/profile/components/UserProfile.vue'<br><br># Good \u2705 \u2705 \u2705<br>import { UserProfile } from '@/features/profile'</pre>\n<p>We can enforce this pattern by using the no-restricted-imports ESLint\u00a0rule.</p>\n<pre>rules: {<br>    'no-restricted-imports': [<br>      'error',<br>      {<br>        patterns: ['@/features/*/*'],<br>      },<br>    ],<br>    'import/no-cycle': 'error',<br>    ...<br>}</pre>\n<h3>Conclusion</h3>\n<p>Feature-oriented architecture is an effective and battle-tested way of structuring complex projects. It allows us to decouple the code into separate modules, and scale our application as it grows more complex. This will improve the development experience by increasing the predictability of the codebase, decreasing debugging time and making onboardings easier.</p>\n<blockquote>Is your application structure similar to this? Are you using something different? Please leave a comment\u00a0below.</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ecc0b690968b\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3viiXXIWhBUcEtFXTySzkQ.png\"></figure><p>One of the most critical and challenging aspects of a large-scale application is a good and reasonable folder structure. Before considering breaking the codebase into multiple applications using micro frontends there are some steps that can be followed to improve the architecture at a project level and make the transition easier if you ever consider that\u00a0path.</p>\n<p>The goal is to apply some kind of modularisation that will make the codebase easier to understand by setting boundaries between features and minimizing code coupling and side\u00a0effects.</p>\n<h3>Default Project Structure</h3>\n<p>By default when scaffolding a new project using one of the popular front-end frameworks the component structure is flat and follows no hierarchy whatsoever.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*yPId5D9_0q4MZGxfYhI8OQ.png\"></figure><blockquote>This example uses <a href=\"https://github.com/vuejs/create-vue/tree/main/template/code\">Vue default project structure</a> but <a href=\"https://legacy.reactjs.org/docs/faq-structure.html\">React also doesn\u2019t have an opinion on how you put files into\u00a0folders</a>.</blockquote>\n<ul>\n<li>The <strong>assets</strong> directory stores static assets such as images, fonts, and CSS files used throughout the application.</li>\n<li>The <strong>components</strong> directory contains reusable Vue components. A flat hierarchy is recommended.</li>\n<li>The <strong>main.js</strong> file serves as the entry point of your application, enabling Vue initialization and configuration of plugins or additional libraries.</li>\n<li>The <strong>App.vue</strong> file represents the root component of your application, acting as a container for other components and serving as the main template.</li>\n</ul>\n<p>We have seen the hard way that for a large project, this architecture will soon get out of hand. Some kind of modularisation is needed to be able to easily locate a given file, set boundaries between features, and avoid tight coupling of the components.</p>\n<h3>Breaking the Application into Multiple\u00a0Features</h3>\n<p>Any large application is broken into multiple independent features. Identifying them is not always easy and straightforward but it gets better after some time and experience. Let's try to break together a popular application into sections as an exercise.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tjpCnCQGrQPk6pNQsBtUew.png\"></figure><p>Twitter's homepage has a lot going on. The timeline which is the core of the page is surrounded by many features like a navigation, a tweet creation section, a sidebar with multiple sub-components, a floating messages component etc.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/812/1*7cmlPjkBylF2QR_HBxHSyQ.gif\"></figure><p>Having all of the components that make up these features in the same folder is not maintainable and locating one of them would be extremely hard even when using the IDE\u2019s quick find\u00a0option.</p>\n<h3>A More Elaborate Project Structure</h3>\n<p>From experience, a better and more comprehensive file structure looks like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/352/1*B-EQbBPvvZ8S3zov2EK4bg.png\"></figure><ul>\n<li>\n<strong>components</strong>: All shared components that are used across the entire application.</li>\n<li>\n<strong>composables</strong>: All shared composables.</li>\n<li>\n<strong>config</strong>: Application configuration files.</li>\n<li>\n<strong>features</strong>: Contains all the application features. We want to keep most of the application code inside here. More on this\u00a0later.</li>\n<li>\n<strong>layouts</strong>: Different layouts for the\u00a0pages.</li>\n<li>\n<strong>lib</strong>: Configurations for different third-party libraries that are used in our application.</li>\n<li>\n<strong>pages</strong>: The pages of our application.</li>\n<li>\n<strong>services: </strong>Shared application services and providers.</li>\n<li>\n<strong>stores</strong>: Global state\u00a0stores.</li>\n<li>\n<strong>test</strong>: Test-related mocks, helpers, utilities, and configurations.</li>\n<li>\n<strong>types</strong>: Shared TypeScript type definitions.</li>\n<li>\n<strong>utils</strong>: Shared utility functions.</li>\n</ul>\n<blockquote>Run the following command on your project root to create any folder that doesn't exist\u00a0already.</blockquote>\n<pre>mkdir -p src/{composables,layouts,pages,utils,assets,config,lib,services,test,components,features,stores,types}</pre>\n<p>Three important things to\u00a0note:</p>\n<ul>\n<li>The <strong>Pages</strong> folder is already some kind of modularisation by default both in terms of contexts and in actual chunks that a build tool like webpack or Vite will create. Having all the pages in one place is very helpful but the logic inside them should be kept to the\u00a0minimum.</li>\n<li>For easier maintenance and scalability, we aim to keep most of the application code inside the <strong>features</strong> folder. Every feature folder should contain domain-specific code for a given\u00a0feature.</li>\n<li>In a perfect world, we shouldn't have shared components, composables, stores and services and everything would be inside the corresponding feature folder. Unfortunately in real projects, this cannot be avoided but we should plan ahead and be extra careful when adding something to these\u00a0folders.</li>\n</ul>\n<h4>Features Folder</h4>\n<p>As we mentioned earlier, the majority of our application should live inside the features folder split into multiple sub directories.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/727/1*x1p3EkyYXSQ8RmOMcCOBQQ.png\"></figure><ul>\n<li>\n<strong>api</strong>: All the fetch logic goes here. This decouples the API and the\u00a0UI.</li>\n<li>\n<strong>components</strong>: Feature specific components.</li>\n<li>\n<strong>composables</strong>: Feature specific composables.</li>\n<li>\n<strong>stores</strong>: The state management code. Multiple sub-modules are expected and actually encouraged.</li>\n<li>\n<strong>types</strong>: Feature specific typeScript type definitions.</li>\n<li>\n<strong>index.ts</strong>: This is the entry point of the feature. It behaves as the <strong>public API </strong>of the feature, and it should only export things that should be public for other parts of the application.</li>\n</ul>\n<p>The above<strong>index.ts</strong> file serves as the public API of each feature. When importing something from another domain it should be done only through this file. This should prevent circular dependencies, and also make it easier to find the source of an\u00a0import.</p>\n<pre># Bad \ud83d\udeab \ud83d\udeab \ud83d\udeab<br>import { UserProfile } from '@/features/profile/components/UserProfile.vue'<br><br># Good \u2705 \u2705 \u2705<br>import { UserProfile } from '@/features/profile'</pre>\n<p>We can enforce this pattern by using the no-restricted-imports ESLint\u00a0rule.</p>\n<pre>rules: {<br>    'no-restricted-imports': [<br>      'error',<br>      {<br>        patterns: ['@/features/*/*'],<br>      },<br>    ],<br>    'import/no-cycle': 'error',<br>    ...<br>}</pre>\n<h3>Conclusion</h3>\n<p>Feature-oriented architecture is an effective and battle-tested way of structuring complex projects. It allows us to decouple the code into separate modules, and scale our application as it grows more complex. This will improve the development experience by increasing the predictability of the codebase, decreasing debugging time and making onboardings easier.</p>\n<blockquote>Is your application structure similar to this? Are you using something different? Please leave a comment\u00a0below.</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ecc0b690968b\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "programming",
              "front-end-development",
              "javascript",
              "vue",
              "software-engineering"
          ]
      },
      {
          "title": "Unit Testing a Pinia Component",
          "pubDate": "2023-07-27 17:31:41",
          "link": "https://fadamakis.medium.com/unit-testing-a-pinia-component-37d045582aed?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/37d045582aed",
          "author": "Fotis Adamakis",
          "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*OfqgoVTwpHKOx2Kv0PVVUg.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OfqgoVTwpHKOx2Kv0PVVUg.png\"></figure><p>Pinia is the undisputed state management champion in the Vue 3 world. It provides a more powerful and scalable architecture with an elegant code style following the composition API\u00a0syntax.</p>\n<p>Getting started is straightforward especially if you are coming from Vuex but some subtle differences in unit testing might catch you off guard. Let's explore some real-life scenarios that might save you time in the\u00a0future.</p>\n<h3>Unit testing a Pinia\u00a0store</h3>\n<p>Before we dive into component testing let's explore how a simple store can be tested in isolation. For this, we will use the counter store that comes with the default vue-cli installation boilerplate and looks like\u00a0this.</p>\n<pre>import { ref, computed } from 'vue'<br>import { defineStore } from 'pinia'<br><br>export const useCounterStore = defineStore('counter', () =&gt; {<br>  const count = ref(0)<br><br>  const doubleCount = computed(() =&gt; count.value * 2)<br><br>  function increment(amount = 1) {<br>    count.value += amount<br>  }<br><br>  return { count, doubleCount, increment }<br>})</pre>\n<p>If you are not familiar with Pinia setup stores the following rules\u00a0apply:</p>\n<ul>\n<li>Everything declared with ref and reactive will become the\u00a0state</li>\n<li>Methods will become\u00a0actions</li>\n<li>Computed will become\u00a0getters</li>\n<li>Mutations don't exist, actions update the state directly.</li>\n</ul>\n<p>Testing the store above should be straightforward:</p>\n<pre>import { setActivePinia, createPinia } from 'pinia'<br>import { useCounterStore } from './counter'<br><br>describe('Counter Store', () =&gt; {<br><br>  beforeEach(() =&gt; {<br>    // creates a fresh pinia and make it active so it's automatically picked<br>    // up by any useStore() call without having to pass it to it:<br>    // `useStore(pinia)`<br>    setActivePinia(createPinia())<br>  })<br><br>  it('increment with no parameters should add one to the counter', () =&gt; {<br>    const counter = useCounterStore()<br>    expect(counter.count).toBe(0)<br>    counter.increment()<br>    expect(counter.count).toBe(1)<br>  })<br><br>  it('increment by amount should update the counter', () =&gt; {<br>    const counter = useCounterStore()<br>    counter.increment(10)<br>    expect(counter.count).toBe(10)<br>  })<br><br>  it('doubleCount getter should be double the counter at all times', () =&gt; {<br>    const counter = useCounterStore()<br>    expect(counter.doubleCount).toBe(0)<br>    counter.increment()<br>    expect(counter.count).toBe(1)<br>    expect(counter.doubleCount).toBe(2)<br>  })<br>})</pre>\n<blockquote>We are using <a href=\"https://vitest.dev/\">vittest</a> which is a vite powered test runner with the same API as Jest but significantly faster execution times.</blockquote>\n<p>Please notice that in the beforeEach hook, a pinia instance is created and activated. A store cannot work without it and the following error will be thrown if we omit\u00a0it:</p>\n<pre>Error: [\ud83c\udf4d]: \"getActivePinia()\" was called but there was no active Pinia. Did you forget to install pinia?<br>        const pinia = createPinia()<br>        app.use(pinia)<br>This will fail in production.</pre>\n<h3>Unit Testing Components</h3>\n<p>A simple component that uses the counter store should be easy to implement.</p>\n<pre>&lt;script setup lang=\"ts\"&gt;<br>import { useCounterStore } from '@/stores/counter'<br>const store = useCounterStore()<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=\"counter\"&gt;<br>    &lt;h1&gt;Counter&lt;/h1&gt;<br>    &lt;p class=\"count\"&gt;The current count is: &lt;span&gt;{{ store.count }}&lt;/span&gt;&lt;/p&gt;<br>    &lt;p class=\"double-count\"&gt;The double count is: &lt;span&gt;{{ store.doubleCount }}&lt;/span&gt;&lt;/p&gt;<br>    &lt;button @click=\"store.increment()\"&gt;<br>      Increment<br>    &lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;</pre>\n<blockquote>Tip: <a href=\"https://pinia.vuejs.org/core-concepts/#destructuring-from-a-store\">StoreToRefs</a> could make this component cleaner by using object destructuring. You can see how in the advanced example that is coming\u00a0next.</blockquote>\n<p>The component is small and simple so writing some basic unit tests are also straightforward.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import TheCounter from '@/components/TheCounter.vue'<br>import { setActivePinia, createPinia } from 'pinia'<br><br>describe('Counter Component', () =&gt; {<br><br>  beforeEach(() =&gt; {<br>    setActivePinia(createPinia())<br>  })<br><br>  test('the count initially should be 0', async () =&gt; {<br>    const wrapper = mount(TheCounter)<br>    expect(wrapper.find('.count span').text()).toBe('0')<br>  })<br><br>  test('clicking the button should increment counter by 1', async () =&gt; {<br>    const wrapper = mount(TheCounter)<br>    await wrapper.find('button').trigger('click')<br>    expect(wrapper.find('.count span').text()).toBe('1')<br>  })<br><br>  test('double counter should be twice the counter value', async () =&gt; {<br>    const wrapper = mount(TheCounter)<br>    expect(wrapper.find('.count span').text()).toBe('0')<br>    expect(wrapper.find('.double-count span').text()).toBe('0')<br>    await wrapper.find('button').trigger('click')<br>    expect(wrapper.find('.count span').text()).toBe('1')<br>    expect(wrapper.find('.double-count span').text()).toBe('2')<br>  })<br><br>})</pre>\n<p>Notice that again we need to create and activate a pinia instance in the beforeEach hook.</p>\n<p>Our basic test suite runs successfully but there is a not-so-obvious issue with it. We are using the actual useCounterStore implementation and we are not testing the Counter component in isolation. It is easy to miss now because our component and store are small but in a real-life scenario everything should be mocked. To mock the store we will use the <a href=\"https://pinia.vuejs.org/api/modules/pinia_testing.html\">createTestingPinia</a> helper from the @pinia/testing package. (Install it with npm i -D @pinia/testing if you haven't already). createTestingPinia will provide many useful behaviours so we can test our component in isolation.</p>\n<p>First, we need to install it as a plugin when mounting a component.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import TheCounter from '@/components/TheCounter.vue'<br>import { createTestingPinia } from '@pinia/testing'<br><br>describe('Counter Component', () =&gt; {<br>  test('the count initially should be 0', async () =&gt; {<br>    const wrapper = mount(TheCounter, {<br>      global: {<br>        plugins: [<br>          createTestingPinia()<br>        ]<br>      }<br>    })<br>    expect(wrapper.find('.count span').text()).toBe('0')<br>  })<br>})</pre>\n<p>We can change the initial state of our store with the initialState configuration.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import TheCounter from '@/components/TheCounter.vue'<br>import { createTestingPinia } from '@pinia/testing'<br><br>describe('Counter Component', () =&gt; {<br> test('the count initially should be 20', async () =&gt; {<br>    const wrapper = mount(TheCounter, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              counter: {<br>                count: 20<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.find('.count span').text()).toBe('20')<br>  })<br>})</pre>\n<p>By default, every action is mocked and will not be executed. We need to implement the behaviour of the action ourselves (see advanced use case below) or we can revert this behaviour with the stubActions configuration. This way the action will be executed but the behavior can be monitored by using\u00a0spies.</p>\n<pre>  test('clicking the button should increment counter by 1', async () =&gt; {<br>    const wrapper = mount(TheCounter, {<br>      global: {<br>        plugins: [createTestingPinia({ stubActions: false })]<br>      }<br>    })<br>    await wrapper.find('button').trigger('click')<br>    expect(wrapper.find('.count span').text()).toBe('1')<br>  })</pre>\n<h3>Advanced Use\u00a0Case</h3>\n<p>Testing a simple counter component is essential to understand the basics but real-life complexity comes when testing asynchronous code. Let's complicate things a\u00a0bit.</p>\n<p>For this, we will use the product listing component again, also featured in my previous <a href=\"https://medium.com/@fadamakis/advanced-data-fetching-with-vue-query-3a06ede0af27?source=your_stories_page-------------------------------------\">Vue Query</a> and <a href=\"https://medium.com/@fadamakis/building-reusable-and-maintainable-components-in-vue-with-the-data-provider-pattern-2797876c007d?source=your_stories_page-------------------------------------\">Data Provider Pattern</a> articles.</p>\n<figure><a href=\"https://fadamakis.github.io/vue-testing-pinia/\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*gug6098-28MRUcg1.gif\"></a></figure><p>The store that will do all the heavy lifting looks like\u00a0this:</p>\n<pre>import { ref } from 'vue'<br>import { defineStore } from 'pinia'<br><br>export type Item = {<br>  id: number;<br>  title: string;<br>  description: string;<br>  price: number;<br>  rating: number;<br>  brand: string;<br>};<br><br>export const useProducts = defineStore('products', () =&gt; {<br>  const products = ref([])<br>  const loading = ref(false)<br><br>  async function fetchData() {<br>    loading.value = true<br>    const response = await fetch(`https://dummyjson.com/products?limit=10`).then((res) =&gt;<br>      res.json()<br>    )<br>    products.value = response.products<br>    loading.value = false<br>  }<br><br>  const selectedProduct = ref()<br><br>  function onSelect(item: Item) {<br>    selectedProduct.value = item<br>  }<br><br>  return { products, loading, fetchData, selectedProduct, onSelect }<br>})</pre>\n<p>The product page will show a loader, the table, an empty state or a product modal depending on the current\u00a0state.</p>\n<pre>&lt;script setup lang=\"ts\"&gt;<br>import TheTable from \"@/components/TheTable.vue\";<br>import ProductModal from \"@/components/ProductModal.vue\";<br>import { storeToRefs } from \"pinia\";<br>import { useProducts } from \"@/stores/products\";<br>import TheLoader from \"@/components/TheLoader.vue\";<br><br>const productsStore = useProducts();<br>const { fetchData, onSelect } = productsStore;<br>const { products, loading, selectedProduct } = storeToRefs(productsStore);<br><br>fetchData();<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=\"container\"&gt;<br>    &lt;TheLoader v-if=\"loading\" /&gt;<br>    &lt;TheTable :items=\"products\" v-else-if=\"products.length\" @select=\"onSelect\" /&gt;<br>    &lt;div v-else class=\"empty-state\"&gt;No products found&lt;/div&gt;<br>    &lt;ProductModal<br>      v-if=\"selectedProduct\"<br>      :product-id=\"selectedProduct.id\"<br>      @close=\"selectedProduct = null\"<br>    /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;</pre>\n<p>It\u2019s important to understand that the product store internals are not a concern of this component. The store should be tested of course but in isolation and on it\u2019s own spec\u00a0file.</p>\n<p>On the other hand every possible state of this component should be mocked and tested. This includes the hidden logic behind every v-if in the template.</p>\n<p>Let's start with a simple test. When loading is true the loader component should be\u00a0shown.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import ProductPage from '@/components/ProductsPage.vue'<br>import { createTestingPinia } from '@pinia/testing'<br>import TheLoader from \"@/components/TheLoader.vue\";<br><br><br>describe('Products Page', () =&gt; {<br>  test('the loader is shown when is loading is true', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                loading: true<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(TheLoader).exists()).toBe(true)<br>  })<br>})</pre>\n<p>Notice that we are mocking the store using createTestingPinia and we are setting the initial state of the loading variable to true. Then we are using the <a href=\"https://v1.test-utils.vuejs.org/api/wrapper/findcomponent.html\">findComponent helper</a> to verify that It is\u00a0visible.</p>\n<p>In the same manner, we can mock all the different states and assert that the expected components are\u00a0shown.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import ProductPage from '@/components/ProductsPage.vue'<br>import { createTestingPinia } from '@pinia/testing'<br>import TheTable from \"@/components/TheTable.vue\";<br>import ProductModal from \"@/components/ProductModal.vue\";<br><br>describe('Products Page', () =&gt; {<br>  test('the table is shown when products exists and the loading state is false', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                loading: false,<br>                products: mockProducts,<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(TheLoader).exists()).toBe(false)<br>    expect(wrapper.findComponent(TheTable).exists()).toBe(true)<br>  })<br>  test('the table is shown when products exists and the loading state is false', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                loading: false,<br>                products: mockProducts,<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(TheLoader).exists()).toBe(false)<br>    expect(wrapper.findComponent(TheTable).exists()).toBe(true)<br>  })<br><br>  test('the empty state is shown when products dont exist and the loading state is false', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                loading: false,<br>                products: [],<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(TheLoader).exists()).toBe(false)<br>    expect(wrapper.findComponent(TheTable).exists()).toBe(false)<br>    expect(wrapper.find('.empty-state').exists()).toBe(true)<br>  })<br><br>  test('the empty state is shown when products dont exist and the loading state is false', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                selectedProduct: mockProducts[0],<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(ProductModal).exists()).toBe(true)<br>  })<br>})<br><br>const mockProducts = [<br>  {<br>    id: 1,<br>    title: \"Mechanical Keyboard\",<br>    description: \"Noisy Mechanical Keyboard\",<br>    price: 100,<br>    rating: 3,<br>    brand: \"Logitech\",<br>  },<br>  {<br>    id: 2,<br>    title: \"Macbook Pro\",<br><br>    description: \"M2\",<br>    price: 1200,<br>    rating: 5,<br>    brand: \"Apple\",<br>  }]</pre>\n<p>Every possible state of the component is tested by successfully mocking the store and respecting the test boundaries of our component. The complete suite can be found on\u00a0<a href=\"https://github.com/fadamakis/vue-testing-pinia\">GitHub</a>.</p>\n<h3>Bonus: Running the Tests on\u00a0CI/CD</h3>\n<p>We recently learned <a href=\"https://fadamakis.com/automatic-deployment-of-a-vue-application-on-github-pages-for-free-4f009f9e4349\">how to deploy a similar application to GitHub pages</a>. But what about verifying that the test suite is successful before a deployment? We can do that by an additional step that runs the unit tests in the pipeline.</p>\n<pre># Simple workflow for deploying static content to GitHub Pages<br>name: Deploy static content to Pages<br><br>on:<br>  # Runs on pushes targeting the default branch<br>  push:<br>    branches: [\"main\"]<br><br>  # Allows you to run this workflow manually from the Actions tab<br>  workflow_dispatch:<br><br># Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages<br>permissions:<br>  contents: read<br>  pages: write<br>  id-token: write<br><br># Allow one concurrent deployment<br>concurrency:<br>  group: \"pages\"<br>  cancel-in-progress: true<br><br>jobs:<br>  test:<br>    runs-on: ubuntu-latest<br>    steps:<br>      - name: Checkout<br>        uses: actions/checkout@v3<br><br>      - name: Set up Node<br>        uses: actions/setup-node@v3<br>        with:<br>          node-version: 18<br>          cache: \"npm\"<br><br>      - name: Install dependencies<br>        run: npm ci<br><br>      - name: Run tests<br>        run: npm run test:unit<br>  deploy:<br>    needs: test<br>    environment:<br>      name: github-pages<br>      url: ${{ steps.deployment.outputs.page_url }}<br>    runs-on: ubuntu-latest<br>    steps:<br>      - name: Checkout<br>        uses: actions/checkout@v3<br>      - name: Set up Node<br>        uses: actions/setup-node@v3<br>        with:<br>          node-version: 18<br>          cache: \"npm\"<br>      - name: Install dependencies<br>        run: npm install<br>      - name: Build<br>        run: npm run build<br>      - name: Setup Pages<br>        uses: actions/configure-pages@v3<br>      - name: Upload artifact<br>        uses: actions/upload-pages-artifact@v1<br>        with:<br>          # Upload dist repository<br>          path: \"./dist\"<br>      - name: Deploy to GitHub Pages<br>        id: deployment<br>        uses: actions/deploy-pages@v1</pre>\n<p>What we added on top of the deploy step is a required test step that prepares the environment and runs npm run test:unit</p>\n<p>In case <a href=\"https://github.com/fadamakis/vue-testing-pinia/actions/runs/5679842576/job/15392766070\">a test fails</a> the deployment will not go\u00a0through.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/796/1*gei8hSzGq0uNZkD6exPkHA.png\"></figure><h3>Conclusion</h3>\n<p>Pinia is the safe bet when it comes to the future of state management in the Vue ecosystem. While the key concepts are similar to Vuex, it may take some time to become comfortable with the new\u00a0API.</p>\n<p>The most important key takeaway from this article is to respect the component boundaries when unit testing by mocking every external dependency and providing the data to cover every possible state of your component.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/131/1*Cq1aKyuOPDBErrfZDfz0lQ@2x.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=37d045582aed\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OfqgoVTwpHKOx2Kv0PVVUg.png\"></figure><p>Pinia is the undisputed state management champion in the Vue 3 world. It provides a more powerful and scalable architecture with an elegant code style following the composition API\u00a0syntax.</p>\n<p>Getting started is straightforward especially if you are coming from Vuex but some subtle differences in unit testing might catch you off guard. Let's explore some real-life scenarios that might save you time in the\u00a0future.</p>\n<h3>Unit testing a Pinia\u00a0store</h3>\n<p>Before we dive into component testing let's explore how a simple store can be tested in isolation. For this, we will use the counter store that comes with the default vue-cli installation boilerplate and looks like\u00a0this.</p>\n<pre>import { ref, computed } from 'vue'<br>import { defineStore } from 'pinia'<br><br>export const useCounterStore = defineStore('counter', () =&gt; {<br>  const count = ref(0)<br><br>  const doubleCount = computed(() =&gt; count.value * 2)<br><br>  function increment(amount = 1) {<br>    count.value += amount<br>  }<br><br>  return { count, doubleCount, increment }<br>})</pre>\n<p>If you are not familiar with Pinia setup stores the following rules\u00a0apply:</p>\n<ul>\n<li>Everything declared with ref and reactive will become the\u00a0state</li>\n<li>Methods will become\u00a0actions</li>\n<li>Computed will become\u00a0getters</li>\n<li>Mutations don't exist, actions update the state directly.</li>\n</ul>\n<p>Testing the store above should be straightforward:</p>\n<pre>import { setActivePinia, createPinia } from 'pinia'<br>import { useCounterStore } from './counter'<br><br>describe('Counter Store', () =&gt; {<br><br>  beforeEach(() =&gt; {<br>    // creates a fresh pinia and make it active so it's automatically picked<br>    // up by any useStore() call without having to pass it to it:<br>    // `useStore(pinia)`<br>    setActivePinia(createPinia())<br>  })<br><br>  it('increment with no parameters should add one to the counter', () =&gt; {<br>    const counter = useCounterStore()<br>    expect(counter.count).toBe(0)<br>    counter.increment()<br>    expect(counter.count).toBe(1)<br>  })<br><br>  it('increment by amount should update the counter', () =&gt; {<br>    const counter = useCounterStore()<br>    counter.increment(10)<br>    expect(counter.count).toBe(10)<br>  })<br><br>  it('doubleCount getter should be double the counter at all times', () =&gt; {<br>    const counter = useCounterStore()<br>    expect(counter.doubleCount).toBe(0)<br>    counter.increment()<br>    expect(counter.count).toBe(1)<br>    expect(counter.doubleCount).toBe(2)<br>  })<br>})</pre>\n<blockquote>We are using <a href=\"https://vitest.dev/\">vittest</a> which is a vite powered test runner with the same API as Jest but significantly faster execution times.</blockquote>\n<p>Please notice that in the beforeEach hook, a pinia instance is created and activated. A store cannot work without it and the following error will be thrown if we omit\u00a0it:</p>\n<pre>Error: [\ud83c\udf4d]: \"getActivePinia()\" was called but there was no active Pinia. Did you forget to install pinia?<br>        const pinia = createPinia()<br>        app.use(pinia)<br>This will fail in production.</pre>\n<h3>Unit Testing Components</h3>\n<p>A simple component that uses the counter store should be easy to implement.</p>\n<pre>&lt;script setup lang=\"ts\"&gt;<br>import { useCounterStore } from '@/stores/counter'<br>const store = useCounterStore()<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=\"counter\"&gt;<br>    &lt;h1&gt;Counter&lt;/h1&gt;<br>    &lt;p class=\"count\"&gt;The current count is: &lt;span&gt;{{ store.count }}&lt;/span&gt;&lt;/p&gt;<br>    &lt;p class=\"double-count\"&gt;The double count is: &lt;span&gt;{{ store.doubleCount }}&lt;/span&gt;&lt;/p&gt;<br>    &lt;button @click=\"store.increment()\"&gt;<br>      Increment<br>    &lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;</pre>\n<blockquote>Tip: <a href=\"https://pinia.vuejs.org/core-concepts/#destructuring-from-a-store\">StoreToRefs</a> could make this component cleaner by using object destructuring. You can see how in the advanced example that is coming\u00a0next.</blockquote>\n<p>The component is small and simple so writing some basic unit tests are also straightforward.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import TheCounter from '@/components/TheCounter.vue'<br>import { setActivePinia, createPinia } from 'pinia'<br><br>describe('Counter Component', () =&gt; {<br><br>  beforeEach(() =&gt; {<br>    setActivePinia(createPinia())<br>  })<br><br>  test('the count initially should be 0', async () =&gt; {<br>    const wrapper = mount(TheCounter)<br>    expect(wrapper.find('.count span').text()).toBe('0')<br>  })<br><br>  test('clicking the button should increment counter by 1', async () =&gt; {<br>    const wrapper = mount(TheCounter)<br>    await wrapper.find('button').trigger('click')<br>    expect(wrapper.find('.count span').text()).toBe('1')<br>  })<br><br>  test('double counter should be twice the counter value', async () =&gt; {<br>    const wrapper = mount(TheCounter)<br>    expect(wrapper.find('.count span').text()).toBe('0')<br>    expect(wrapper.find('.double-count span').text()).toBe('0')<br>    await wrapper.find('button').trigger('click')<br>    expect(wrapper.find('.count span').text()).toBe('1')<br>    expect(wrapper.find('.double-count span').text()).toBe('2')<br>  })<br><br>})</pre>\n<p>Notice that again we need to create and activate a pinia instance in the beforeEach hook.</p>\n<p>Our basic test suite runs successfully but there is a not-so-obvious issue with it. We are using the actual useCounterStore implementation and we are not testing the Counter component in isolation. It is easy to miss now because our component and store are small but in a real-life scenario everything should be mocked. To mock the store we will use the <a href=\"https://pinia.vuejs.org/api/modules/pinia_testing.html\">createTestingPinia</a> helper from the @pinia/testing package. (Install it with npm i -D @pinia/testing if you haven't already). createTestingPinia will provide many useful behaviours so we can test our component in isolation.</p>\n<p>First, we need to install it as a plugin when mounting a component.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import TheCounter from '@/components/TheCounter.vue'<br>import { createTestingPinia } from '@pinia/testing'<br><br>describe('Counter Component', () =&gt; {<br>  test('the count initially should be 0', async () =&gt; {<br>    const wrapper = mount(TheCounter, {<br>      global: {<br>        plugins: [<br>          createTestingPinia()<br>        ]<br>      }<br>    })<br>    expect(wrapper.find('.count span').text()).toBe('0')<br>  })<br>})</pre>\n<p>We can change the initial state of our store with the initialState configuration.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import TheCounter from '@/components/TheCounter.vue'<br>import { createTestingPinia } from '@pinia/testing'<br><br>describe('Counter Component', () =&gt; {<br> test('the count initially should be 20', async () =&gt; {<br>    const wrapper = mount(TheCounter, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              counter: {<br>                count: 20<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.find('.count span').text()).toBe('20')<br>  })<br>})</pre>\n<p>By default, every action is mocked and will not be executed. We need to implement the behaviour of the action ourselves (see advanced use case below) or we can revert this behaviour with the stubActions configuration. This way the action will be executed but the behavior can be monitored by using\u00a0spies.</p>\n<pre>  test('clicking the button should increment counter by 1', async () =&gt; {<br>    const wrapper = mount(TheCounter, {<br>      global: {<br>        plugins: [createTestingPinia({ stubActions: false })]<br>      }<br>    })<br>    await wrapper.find('button').trigger('click')<br>    expect(wrapper.find('.count span').text()).toBe('1')<br>  })</pre>\n<h3>Advanced Use\u00a0Case</h3>\n<p>Testing a simple counter component is essential to understand the basics but real-life complexity comes when testing asynchronous code. Let's complicate things a\u00a0bit.</p>\n<p>For this, we will use the product listing component again, also featured in my previous <a href=\"https://medium.com/@fadamakis/advanced-data-fetching-with-vue-query-3a06ede0af27?source=your_stories_page-------------------------------------\">Vue Query</a> and <a href=\"https://medium.com/@fadamakis/building-reusable-and-maintainable-components-in-vue-with-the-data-provider-pattern-2797876c007d?source=your_stories_page-------------------------------------\">Data Provider Pattern</a> articles.</p>\n<figure><a href=\"https://fadamakis.github.io/vue-testing-pinia/\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*gug6098-28MRUcg1.gif\"></a></figure><p>The store that will do all the heavy lifting looks like\u00a0this:</p>\n<pre>import { ref } from 'vue'<br>import { defineStore } from 'pinia'<br><br>export type Item = {<br>  id: number;<br>  title: string;<br>  description: string;<br>  price: number;<br>  rating: number;<br>  brand: string;<br>};<br><br>export const useProducts = defineStore('products', () =&gt; {<br>  const products = ref([])<br>  const loading = ref(false)<br><br>  async function fetchData() {<br>    loading.value = true<br>    const response = await fetch(`https://dummyjson.com/products?limit=10`).then((res) =&gt;<br>      res.json()<br>    )<br>    products.value = response.products<br>    loading.value = false<br>  }<br><br>  const selectedProduct = ref()<br><br>  function onSelect(item: Item) {<br>    selectedProduct.value = item<br>  }<br><br>  return { products, loading, fetchData, selectedProduct, onSelect }<br>})</pre>\n<p>The product page will show a loader, the table, an empty state or a product modal depending on the current\u00a0state.</p>\n<pre>&lt;script setup lang=\"ts\"&gt;<br>import TheTable from \"@/components/TheTable.vue\";<br>import ProductModal from \"@/components/ProductModal.vue\";<br>import { storeToRefs } from \"pinia\";<br>import { useProducts } from \"@/stores/products\";<br>import TheLoader from \"@/components/TheLoader.vue\";<br><br>const productsStore = useProducts();<br>const { fetchData, onSelect } = productsStore;<br>const { products, loading, selectedProduct } = storeToRefs(productsStore);<br><br>fetchData();<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=\"container\"&gt;<br>    &lt;TheLoader v-if=\"loading\" /&gt;<br>    &lt;TheTable :items=\"products\" v-else-if=\"products.length\" @select=\"onSelect\" /&gt;<br>    &lt;div v-else class=\"empty-state\"&gt;No products found&lt;/div&gt;<br>    &lt;ProductModal<br>      v-if=\"selectedProduct\"<br>      :product-id=\"selectedProduct.id\"<br>      @close=\"selectedProduct = null\"<br>    /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;</pre>\n<p>It\u2019s important to understand that the product store internals are not a concern of this component. The store should be tested of course but in isolation and on it\u2019s own spec\u00a0file.</p>\n<p>On the other hand every possible state of this component should be mocked and tested. This includes the hidden logic behind every v-if in the template.</p>\n<p>Let's start with a simple test. When loading is true the loader component should be\u00a0shown.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import ProductPage from '@/components/ProductsPage.vue'<br>import { createTestingPinia } from '@pinia/testing'<br>import TheLoader from \"@/components/TheLoader.vue\";<br><br><br>describe('Products Page', () =&gt; {<br>  test('the loader is shown when is loading is true', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                loading: true<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(TheLoader).exists()).toBe(true)<br>  })<br>})</pre>\n<p>Notice that we are mocking the store using createTestingPinia and we are setting the initial state of the loading variable to true. Then we are using the <a href=\"https://v1.test-utils.vuejs.org/api/wrapper/findcomponent.html\">findComponent helper</a> to verify that It is\u00a0visible.</p>\n<p>In the same manner, we can mock all the different states and assert that the expected components are\u00a0shown.</p>\n<pre>import { mount } from '@vue/test-utils'<br>import ProductPage from '@/components/ProductsPage.vue'<br>import { createTestingPinia } from '@pinia/testing'<br>import TheTable from \"@/components/TheTable.vue\";<br>import ProductModal from \"@/components/ProductModal.vue\";<br><br>describe('Products Page', () =&gt; {<br>  test('the table is shown when products exists and the loading state is false', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                loading: false,<br>                products: mockProducts,<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(TheLoader).exists()).toBe(false)<br>    expect(wrapper.findComponent(TheTable).exists()).toBe(true)<br>  })<br>  test('the table is shown when products exists and the loading state is false', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                loading: false,<br>                products: mockProducts,<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(TheLoader).exists()).toBe(false)<br>    expect(wrapper.findComponent(TheTable).exists()).toBe(true)<br>  })<br><br>  test('the empty state is shown when products dont exist and the loading state is false', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                loading: false,<br>                products: [],<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(TheLoader).exists()).toBe(false)<br>    expect(wrapper.findComponent(TheTable).exists()).toBe(false)<br>    expect(wrapper.find('.empty-state').exists()).toBe(true)<br>  })<br><br>  test('the empty state is shown when products dont exist and the loading state is false', async () =&gt; {<br>    const wrapper = mount(ProductPage, {<br>      global: {<br>        plugins: [<br>          createTestingPinia({<br>            initialState: {<br>              products: {<br>                selectedProduct: mockProducts[0],<br>              }<br>            }<br>          })<br>        ]<br>      }<br>    })<br>    expect(wrapper.findComponent(ProductModal).exists()).toBe(true)<br>  })<br>})<br><br>const mockProducts = [<br>  {<br>    id: 1,<br>    title: \"Mechanical Keyboard\",<br>    description: \"Noisy Mechanical Keyboard\",<br>    price: 100,<br>    rating: 3,<br>    brand: \"Logitech\",<br>  },<br>  {<br>    id: 2,<br>    title: \"Macbook Pro\",<br><br>    description: \"M2\",<br>    price: 1200,<br>    rating: 5,<br>    brand: \"Apple\",<br>  }]</pre>\n<p>Every possible state of the component is tested by successfully mocking the store and respecting the test boundaries of our component. The complete suite can be found on\u00a0<a href=\"https://github.com/fadamakis/vue-testing-pinia\">GitHub</a>.</p>\n<h3>Bonus: Running the Tests on\u00a0CI/CD</h3>\n<p>We recently learned <a href=\"https://fadamakis.com/automatic-deployment-of-a-vue-application-on-github-pages-for-free-4f009f9e4349\">how to deploy a similar application to GitHub pages</a>. But what about verifying that the test suite is successful before a deployment? We can do that by an additional step that runs the unit tests in the pipeline.</p>\n<pre># Simple workflow for deploying static content to GitHub Pages<br>name: Deploy static content to Pages<br><br>on:<br>  # Runs on pushes targeting the default branch<br>  push:<br>    branches: [\"main\"]<br><br>  # Allows you to run this workflow manually from the Actions tab<br>  workflow_dispatch:<br><br># Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages<br>permissions:<br>  contents: read<br>  pages: write<br>  id-token: write<br><br># Allow one concurrent deployment<br>concurrency:<br>  group: \"pages\"<br>  cancel-in-progress: true<br><br>jobs:<br>  test:<br>    runs-on: ubuntu-latest<br>    steps:<br>      - name: Checkout<br>        uses: actions/checkout@v3<br><br>      - name: Set up Node<br>        uses: actions/setup-node@v3<br>        with:<br>          node-version: 18<br>          cache: \"npm\"<br><br>      - name: Install dependencies<br>        run: npm ci<br><br>      - name: Run tests<br>        run: npm run test:unit<br>  deploy:<br>    needs: test<br>    environment:<br>      name: github-pages<br>      url: ${{ steps.deployment.outputs.page_url }}<br>    runs-on: ubuntu-latest<br>    steps:<br>      - name: Checkout<br>        uses: actions/checkout@v3<br>      - name: Set up Node<br>        uses: actions/setup-node@v3<br>        with:<br>          node-version: 18<br>          cache: \"npm\"<br>      - name: Install dependencies<br>        run: npm install<br>      - name: Build<br>        run: npm run build<br>      - name: Setup Pages<br>        uses: actions/configure-pages@v3<br>      - name: Upload artifact<br>        uses: actions/upload-pages-artifact@v1<br>        with:<br>          # Upload dist repository<br>          path: \"./dist\"<br>      - name: Deploy to GitHub Pages<br>        id: deployment<br>        uses: actions/deploy-pages@v1</pre>\n<p>What we added on top of the deploy step is a required test step that prepares the environment and runs npm run test:unit</p>\n<p>In case <a href=\"https://github.com/fadamakis/vue-testing-pinia/actions/runs/5679842576/job/15392766070\">a test fails</a> the deployment will not go\u00a0through.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/796/1*gei8hSzGq0uNZkD6exPkHA.png\"></figure><h3>Conclusion</h3>\n<p>Pinia is the safe bet when it comes to the future of state management in the Vue ecosystem. While the key concepts are similar to Vuex, it may take some time to become comfortable with the new\u00a0API.</p>\n<p>The most important key takeaway from this article is to respect the component boundaries when unit testing by mocking every external dependency and providing the data to cover every possible state of your component.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/131/1*Cq1aKyuOPDBErrfZDfz0lQ@2x.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=37d045582aed\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "javascript",
              "pinia",
              "vuejs",
              "vue",
              "front-end-development"
          ]
      },
      {
          "title": "React + Signals = Vue 3",
          "pubDate": "2023-07-26 09:46:01",
          "link": "https://fadamakis.medium.com/react-signals-vue-3-463fefc51129?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/463fefc51129",
          "author": "Fotis Adamakis",
          "thumbnail": "https://cdn-images-1.medium.com/max/680/1*Pr3EW7elF9-imr8eFg_RWg.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/680/1*Pr3EW7elF9-imr8eFg_RWg.png\"></figure><p>Signals are being adopted rapidly by all modern javascript frameworks. They have been around forever but resurfaced recently by <a href=\"https://www.solidjs.com/tutorial/introduction_signals\">Solidjs</a>, and now every major javascript framework including <a href=\"https://qwik.builder.io/docs/components/state/#usesignal\">Qwik</a>, <a href=\"https://preactjs.com/guide/v10/signals/\">Preact</a>, and <a href=\"https://github.com/angular/angular/discussions/49090\">Angular</a> are adopting them. They can significantly reduce boilerplate but inevitably the implementation will look more or less the same no matter the underlying framework. Let's see an example featuring the two more popular frameworks right now, React and\u00a0Vue.</p>\n<h3>Understanding the\u00a0problem</h3>\n<p>Javascript is a very powerful language, but it's not well suited for reactive programming. To demonstrate the problem let's use a simple code\u00a0snippet:</p>\n<pre>let a = 1<br>let b = 2<br><br>let c = a + b // 3<br><br>a += 1<br><br>console.log(c) // 3, but a + b is now 4</pre>\n<p>This is essentially the problem many reactive libraries are trying to\u00a0solve.</p>\n<h3>Understanding Signals</h3>\n<p>Signals are a way to represent and manage state in a reactive way. They are essentially <strong>event-driven variables</strong> that can be subscribed to by other parts of the application. When the value of a signal changes, all of its subscribers are notified and their code will re-run. This allows for a very efficient way to update the UI in response to changes in\u00a0state.</p>\n<p>It is easy to understand with a small example written in\u00a0<a href=\"https://www.solidjs.com/\">SolidJs</a>:</p>\n<pre>const [count, setCount] = createSignal(0);<br><br>// Set the initial value of the signal<br>count = 10;<br><br>// Subscribe to the signal and print the current value<br>count.subscribe(value =&gt; console.log(value));<br><br>// Change the value of the signal<br>setCount(20);</pre>\n<h3>Adoption in\u00a0React</h3>\n<p><em>From useState to\u00a0Signals</em></p>\n<p>Currently, to manage state between components in react you need to pass it through props, create some context or use something like redux that comes with its own set of problems and boilerplate.</p>\n<p>Preact, which is branded as a lightweight and fast version of React, is showing the way by implementing signals\u00a0first.</p>\n<p>At its core, a signal in Preact is an object with a\u00a0.value property that holds the value. The value can change, but the signal itself always stays the\u00a0same.</p>\n<pre>import { signal } from \"@preact/signals\";<br><br>const count = signal(0);<br><br>// Read a signal\u2019s value by accessing .value:<br>console.log(count.value);   // 0<br><br>// Update a signal\u2019s value:<br>count.value += 1;<br><br>// The signal's value has changed:<br>console.log(count.value);  // 1</pre>\n<p>In Preact, when a signal is passed down through a tree as props or context, we are only passing around <strong>references</strong> to the signal itself. This means that the signal can be updated without re-rendering any components that are not subscribed to the signal. This is because the components see the signal, not its value. As a result, Preact can skip the expensive rendering work and only re-render the components that actually need to be\u00a0updated.</p>\n<p>Signals have a second important characteristic: they track when their value is accessed and when it is updated. This means that when you access a signal\u2019s\u00a0.value from within a component, Preact will automatically re-render the component if the signal\u2019s value has changed since the last time the component was rendered. This ensures that the UI always reflects the current state of the application.</p>\n<pre>import { signal } from \"@preact/signals\";<br><br>// Create a signal that can be subscribed to:<br>const count = signal(0);<br><br>function Counter() {<br>  // Accessing .value in a component automatically re-renders when it changes:<br>  const value = count.value;<br><br>  const increment = () =&gt; {<br>    // A signal is updated by assigning to the `.value` property:<br>    count.value++;<br>  }<br><br>  return (<br>    &lt;div&gt;<br>      &lt;p&gt;Count: {value}&lt;/p&gt;<br>      &lt;button onClick={increment}&gt;click me&lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<p>Additionally, multiple signals can be combined using the <a href=\"https://preactjs.com/guide/v10/signals/#computedfn\">computed</a> function. The returned computed signal is read-only, and its value is automatically updated when any signals accessed from within the callback function\u00a0change.</p>\n<pre>import { signal, computed } from \"@preact/signals\";<br><br>const todos = signal([<br>  { text: \"Buy groceries\", completed: true },<br>  { text: \"Walk the dog\", completed: false },<br>]);<br><br>// create a signal computed from other signals<br>const completed = computed(() =&gt; {<br>  // When `todos` changes, this re-runs automatically:<br>  return todos.value.filter(todo =&gt; todo.completed).length;<br>});<br><br>// Logs: 1, because one todo is marked as being completed<br>console.log(completed.value);</pre>\n<p>Everything above is written in Preact but is directly transferable to react using the package <a href=\"https://www.npmjs.com/package/@preact/signals-react\">signals-react</a> and using the same\u00a0syntax.</p>\n<pre>// React component<br>import { signal } from \"@preact/signals-react\";<br><br>const count = signal(0);<br><br>function CounterValue() {<br> // Whenever the `count` signal is updated, we'll<br> // re-render this component automatically for you<br> return &lt;p&gt;Value: {count.value}&lt;/p&gt;;<br>}</pre>\n<h3>Signals in\u00a0Vue</h3>\n<p>If you are a Vue developer but not familiar with Signals everything above should be easy to follow. The code looks almost identical to Vue\u00a03.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*mH513_42JsYsF51O.jpg\"><figcaption>Vue Developer Reading Signals in\u00a0Preact</figcaption></figure><p>This is because reactivity is the fundamental idea behind Vue even since version 1. The same code in Vue would look like\u00a0this:</p>\n<pre>import { reactive, computed } from \"vue\";<br><br>const todos = reactive([<br>  { text: \"Buy groceries\", completed: false },<br>  { text: \"Walk the dog\", completed: false },<br>]);<br><br>const completed = computed(() =&gt; {<br>  return todos.filter(todo =&gt; todo.completed).length;<br>});<br><br>todos[0].completed = true<br><br>console.log(completed.value);</pre>\n<p>The code is almost identical to the code written in React using @preact/signals!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*w3YgGdD9G_rZXQ0V.jpg\"></figure><h3>Conclusion</h3>\n<p>It\u2019s apparent that the code looks the same. But is this a bad thing? Signals are definitely doing something well and this is why all the major frameworks are adopting them rapidly. But at the end of the day, maintainable code and good development ergonomics are what we want, and having all the frameworks using the same tools will create synergies that everyone will benefit from. Additionally having a skill transferable between frameworks and different codebases can only be beneficial to someone's career.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/131/1*Cq1aKyuOPDBErrfZDfz0lQ@2x.png\"></figure><h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf\">A Hands-on Introduction to Fine-Grained Reactivity</a></li>\n<li><a href=\"https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob\">The Evolution of Signals in JavaScript</a></li>\n<li><a href=\"https://itnext.io/signals-whats-going-on-behind-the-scenes-ec858589ea63\">Signals\u200a\u2014\u200awhat's going on behind the\u00a0scenes</a></li>\n<li><a href=\"https://www.skcript.com/blog/react-signals\">What are React Signals? Why and when to use\u00a0it?</a></li>\n<li><a href=\"https://preactjs.com/blog/introducing-signals/\">Preact.js: Introducing Signals</a></li>\n<li>\n<a href=\"https://vuejs.org/guide/extras/reactivity-in-depth.html#connection-to-signals\">Vue Reactivity - Connection to signals</a> (by Evan\u00a0You)</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=463fefc51129\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/680/1*Pr3EW7elF9-imr8eFg_RWg.png\"></figure><p>Signals are being adopted rapidly by all modern javascript frameworks. They have been around forever but resurfaced recently by <a href=\"https://www.solidjs.com/tutorial/introduction_signals\">Solidjs</a>, and now every major javascript framework including <a href=\"https://qwik.builder.io/docs/components/state/#usesignal\">Qwik</a>, <a href=\"https://preactjs.com/guide/v10/signals/\">Preact</a>, and <a href=\"https://github.com/angular/angular/discussions/49090\">Angular</a> are adopting them. They can significantly reduce boilerplate but inevitably the implementation will look more or less the same no matter the underlying framework. Let's see an example featuring the two more popular frameworks right now, React and\u00a0Vue.</p>\n<h3>Understanding the\u00a0problem</h3>\n<p>Javascript is a very powerful language, but it's not well suited for reactive programming. To demonstrate the problem let's use a simple code\u00a0snippet:</p>\n<pre>let a = 1<br>let b = 2<br><br>let c = a + b // 3<br><br>a += 1<br><br>console.log(c) // 3, but a + b is now 4</pre>\n<p>This is essentially the problem many reactive libraries are trying to\u00a0solve.</p>\n<h3>Understanding Signals</h3>\n<p>Signals are a way to represent and manage state in a reactive way. They are essentially <strong>event-driven variables</strong> that can be subscribed to by other parts of the application. When the value of a signal changes, all of its subscribers are notified and their code will re-run. This allows for a very efficient way to update the UI in response to changes in\u00a0state.</p>\n<p>It is easy to understand with a small example written in\u00a0<a href=\"https://www.solidjs.com/\">SolidJs</a>:</p>\n<pre>const [count, setCount] = createSignal(0);<br><br>// Set the initial value of the signal<br>count = 10;<br><br>// Subscribe to the signal and print the current value<br>count.subscribe(value =&gt; console.log(value));<br><br>// Change the value of the signal<br>setCount(20);</pre>\n<h3>Adoption in\u00a0React</h3>\n<p><em>From useState to\u00a0Signals</em></p>\n<p>Currently, to manage state between components in react you need to pass it through props, create some context or use something like redux that comes with its own set of problems and boilerplate.</p>\n<p>Preact, which is branded as a lightweight and fast version of React, is showing the way by implementing signals\u00a0first.</p>\n<p>At its core, a signal in Preact is an object with a\u00a0.value property that holds the value. The value can change, but the signal itself always stays the\u00a0same.</p>\n<pre>import { signal } from \"@preact/signals\";<br><br>const count = signal(0);<br><br>// Read a signal\u2019s value by accessing .value:<br>console.log(count.value);   // 0<br><br>// Update a signal\u2019s value:<br>count.value += 1;<br><br>// The signal's value has changed:<br>console.log(count.value);  // 1</pre>\n<p>In Preact, when a signal is passed down through a tree as props or context, we are only passing around <strong>references</strong> to the signal itself. This means that the signal can be updated without re-rendering any components that are not subscribed to the signal. This is because the components see the signal, not its value. As a result, Preact can skip the expensive rendering work and only re-render the components that actually need to be\u00a0updated.</p>\n<p>Signals have a second important characteristic: they track when their value is accessed and when it is updated. This means that when you access a signal\u2019s\u00a0.value from within a component, Preact will automatically re-render the component if the signal\u2019s value has changed since the last time the component was rendered. This ensures that the UI always reflects the current state of the application.</p>\n<pre>import { signal } from \"@preact/signals\";<br><br>// Create a signal that can be subscribed to:<br>const count = signal(0);<br><br>function Counter() {<br>  // Accessing .value in a component automatically re-renders when it changes:<br>  const value = count.value;<br><br>  const increment = () =&gt; {<br>    // A signal is updated by assigning to the `.value` property:<br>    count.value++;<br>  }<br><br>  return (<br>    &lt;div&gt;<br>      &lt;p&gt;Count: {value}&lt;/p&gt;<br>      &lt;button onClick={increment}&gt;click me&lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<p>Additionally, multiple signals can be combined using the <a href=\"https://preactjs.com/guide/v10/signals/#computedfn\">computed</a> function. The returned computed signal is read-only, and its value is automatically updated when any signals accessed from within the callback function\u00a0change.</p>\n<pre>import { signal, computed } from \"@preact/signals\";<br><br>const todos = signal([<br>  { text: \"Buy groceries\", completed: true },<br>  { text: \"Walk the dog\", completed: false },<br>]);<br><br>// create a signal computed from other signals<br>const completed = computed(() =&gt; {<br>  // When `todos` changes, this re-runs automatically:<br>  return todos.value.filter(todo =&gt; todo.completed).length;<br>});<br><br>// Logs: 1, because one todo is marked as being completed<br>console.log(completed.value);</pre>\n<p>Everything above is written in Preact but is directly transferable to react using the package <a href=\"https://www.npmjs.com/package/@preact/signals-react\">signals-react</a> and using the same\u00a0syntax.</p>\n<pre>// React component<br>import { signal } from \"@preact/signals-react\";<br><br>const count = signal(0);<br><br>function CounterValue() {<br> // Whenever the `count` signal is updated, we'll<br> // re-render this component automatically for you<br> return &lt;p&gt;Value: {count.value}&lt;/p&gt;;<br>}</pre>\n<h3>Signals in\u00a0Vue</h3>\n<p>If you are a Vue developer but not familiar with Signals everything above should be easy to follow. The code looks almost identical to Vue\u00a03.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*mH513_42JsYsF51O.jpg\"><figcaption>Vue Developer Reading Signals in\u00a0Preact</figcaption></figure><p>This is because reactivity is the fundamental idea behind Vue even since version 1. The same code in Vue would look like\u00a0this:</p>\n<pre>import { reactive, computed } from \"vue\";<br><br>const todos = reactive([<br>  { text: \"Buy groceries\", completed: false },<br>  { text: \"Walk the dog\", completed: false },<br>]);<br><br>const completed = computed(() =&gt; {<br>  return todos.filter(todo =&gt; todo.completed).length;<br>});<br><br>todos[0].completed = true<br><br>console.log(completed.value);</pre>\n<p>The code is almost identical to the code written in React using @preact/signals!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*w3YgGdD9G_rZXQ0V.jpg\"></figure><h3>Conclusion</h3>\n<p>It\u2019s apparent that the code looks the same. But is this a bad thing? Signals are definitely doing something well and this is why all the major frameworks are adopting them rapidly. But at the end of the day, maintainable code and good development ergonomics are what we want, and having all the frameworks using the same tools will create synergies that everyone will benefit from. Additionally having a skill transferable between frameworks and different codebases can only be beneficial to someone's career.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/131/1*Cq1aKyuOPDBErrfZDfz0lQ@2x.png\"></figure><h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf\">A Hands-on Introduction to Fine-Grained Reactivity</a></li>\n<li><a href=\"https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob\">The Evolution of Signals in JavaScript</a></li>\n<li><a href=\"https://itnext.io/signals-whats-going-on-behind-the-scenes-ec858589ea63\">Signals\u200a\u2014\u200awhat's going on behind the\u00a0scenes</a></li>\n<li><a href=\"https://www.skcript.com/blog/react-signals\">What are React Signals? Why and when to use\u00a0it?</a></li>\n<li><a href=\"https://preactjs.com/blog/introducing-signals/\">Preact.js: Introducing Signals</a></li>\n<li>\n<a href=\"https://vuejs.org/guide/extras/reactivity-in-depth.html#connection-to-signals\">Vue Reactivity - Connection to signals</a> (by Evan\u00a0You)</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=463fefc51129\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "javascript",
              "web-development",
              "react",
              "front-end-development",
              "vuejs"
          ]
      },
      {
          "title": "[Vue 3] Why both Ref and Reactive are needed",
          "pubDate": "2023-07-18 23:13:24",
          "link": "https://fadamakis.medium.com/vue-3-why-both-ref-and-reactive-are-needed-344bb5da2593?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/344bb5da2593",
          "author": "Fotis Adamakis",
          "thumbnail": "https://cdn-images-1.medium.com/max/680/1*eDj3LzIpkJVFFH5lzAPK4Q.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/680/1*eDj3LzIpkJVFFH5lzAPK4Q.png\"></figure><p>Declaring Reactive Data while working with the Options API was straightforward. Everything inside the data option was automatically made reactive and was available in the template. The only caveat was to make <a href=\"https://v2.vuejs.org/v2/api/#data\">data a function</a> and prevent sharing state across all component instances.</p>\n<p>With Composition API things are not that simple. State declaration has to be done using the two available utility functions <em>(ref </em>and<em> reactive), </em>with each one behaving differently.</p>\n<p>Let\u2019s discuss what changed in Vue 3 and why we need two different helpers.</p>\n<h3>Reactivity in Vue\u00a02</h3>\n<p>Every property inside the data component option will be converted to<em> </em><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters\"><strong>getter/setters</strong></a> using Object.defineProperty. The getter/setters are invisible to us, but under the hood, they enable Vue to perform dependency-tracking when properties are accessed or modified.</p>\n<p>Every component has an associated watcher that tracks the properties used during the component\u2019s render cycle. If a dependency is updated, the watcher notifies the component, which then triggers a re-render.</p>\n<ul>\n<li><a href=\"https://v2.vuejs.org/v2/guide/reactivity.html\">Vue 2 Reactivity in\u00a0depth</a></li>\n<li><a href=\"https://github.com/vuejs/vue/blob/main/src/core/observer/index.ts#L42-L47\">Vue 2 reactivity source\u00a0code</a></li>\n</ul>\n<h3>Reactivity in Vue\u00a03</h3>\n<p>In Vue 3 everything changed. The core was rewritten from scratch and reactivity is now powered by Javascript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxies</a>. Proxies are a modern and elegant way to observe an object and get notified when a property is accessed or\u00a0updated.</p>\n<p>You can understand how proxies work with the following simple\u00a0example:</p>\n<pre>const userInfo = {<br>  firstName: \"fotis\",<br>  age: 35,<br>};<br><br>const handler = {<br>  get(target, property) {<br>    if (property === \"firstName\") {<br>      const name = target[property]<br>      return name.charAt(0).toUpperCase() + name.slice(1);<br>    }<br>    if (property === \"age\") {<br>      return '--'<br>    }<br>    return target[property]<br>  },<br>};<br><br>const proxy = new Proxy(userInfo, handler);<br><br>console.log(proxy.firstName) // \"Fotis\"<br>console.log(proxy.age) // \"--\"</pre>\n<p>The get method inside the handler is called a trap and will be called every time a property of the object is accessed.</p>\n<p>In a similar manner, a set trap can be\u00a0defined:</p>\n<pre>const userInfo = {<br>  firstName: \"Fotis\",<br>  age: 35,<br>};<br><br>const handler = {<br>  set(target, prop, value) {<br>    if (prop === \"age\") {<br>      if (!Number.isInteger(value)) {<br>        throw new TypeError(\"The age is not an integer\");<br>      }<br>      if (value &gt; 200) {<br>        throw new RangeError(\"The age seems invalid\");<br>      }<br>    }<br>    target[prop] = value;<br>    return true;<br>  },<br>};<br><br>const proxy = new Proxy(userInfo, handler);<br><br>proxy.age = 12 // OK<br>proxy.age = 300 // Error: The age seems invalid</pre>\n<p>This is exactly the idea behind Vue 3 reactivity. When a variable is declared using the reactive helper, a proxy is used to keep track of any\u00a0changes.</p>\n<pre>function reactive(obj) {<br>  return new Proxy(obj, {<br>    get(target, key) {<br>      track(target, key)<br>      return target[key]<br>    },<br>    set(target, key, value) {<br>      target[key] = value<br>      trigger(target, key)<br>    }<br>  })<br>}</pre>\n<blockquote>Of course, the actual <a href=\"https://github.com/vuejs/core/blob/main/packages/reactivity/src/reactive.ts#L83\">implementation of the reactive helper</a> is more sophisticated and handles edge cases but at the core it still uses <a href=\"https://github.com/vuejs/core/blob/main/packages/reactivity/src/reactive.ts#L279-L282\">a\u00a0proxy</a>.</blockquote>\n<p>The snippet above explains why destructuring or reassigning a reactive variable to a local variable is no longer reactive because it no longer triggers the get/set proxy traps on the source\u00a0object.</p>\n<p>This looks like a perfect solution to make everything reactive. But there is a catch! By definition, <strong>proxies only work for complex types</strong>. These are Objects, Arrays, Maps and Sets. To make a primitive reactive we still use a Proxy but we have to wrap it in an Object\u00a0first.</p>\n<pre>function ref(value) {<br>  const refObject = {<br>    get value() {<br>      track(refObject, 'value')<br>      return value<br>    },<br>    set value(newValue) {<br>      value = newValue<br>      trigger(refObject, 'value')<br>    }<br>  }<br>  return refObject<br>}</pre>\n<p>This explains the annoying\u00a0.value that has to be used inside script setup. And again restructuring or reassignment to a local variable doesn\u2019t\u00a0work.</p>\n<ul>\n<li><a href=\"https://vuejs.org/guide/extras/reactivity-in-depth.html\">Vue 3 Reactivity in\u00a0depth</a></li>\n<li><a href=\"https://github.com/vuejs/core/blob/main/packages/reactivity/src/reactive.ts\">Vue 3 reactivity source\u00a0code</a></li>\n</ul>\n<h3>Conclusion</h3>\n<p>So the answer to why both Ref and Reactive are needed is: <em>Proxies</em>. For complex types, they can be used directly but on primitives, a proxy object needs to be\u00a0created.</p>\n<p>Hopefully, understanding how Vue works under the hood can make you more effective and can clear any confusion between ref and reactive.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=344bb5da2593\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/680/1*eDj3LzIpkJVFFH5lzAPK4Q.png\"></figure><p>Declaring Reactive Data while working with the Options API was straightforward. Everything inside the data option was automatically made reactive and was available in the template. The only caveat was to make <a href=\"https://v2.vuejs.org/v2/api/#data\">data a function</a> and prevent sharing state across all component instances.</p>\n<p>With Composition API things are not that simple. State declaration has to be done using the two available utility functions <em>(ref </em>and<em> reactive), </em>with each one behaving differently.</p>\n<p>Let\u2019s discuss what changed in Vue 3 and why we need two different helpers.</p>\n<h3>Reactivity in Vue\u00a02</h3>\n<p>Every property inside the data component option will be converted to<em> </em><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters\"><strong>getter/setters</strong></a> using Object.defineProperty. The getter/setters are invisible to us, but under the hood, they enable Vue to perform dependency-tracking when properties are accessed or modified.</p>\n<p>Every component has an associated watcher that tracks the properties used during the component\u2019s render cycle. If a dependency is updated, the watcher notifies the component, which then triggers a re-render.</p>\n<ul>\n<li><a href=\"https://v2.vuejs.org/v2/guide/reactivity.html\">Vue 2 Reactivity in\u00a0depth</a></li>\n<li><a href=\"https://github.com/vuejs/vue/blob/main/src/core/observer/index.ts#L42-L47\">Vue 2 reactivity source\u00a0code</a></li>\n</ul>\n<h3>Reactivity in Vue\u00a03</h3>\n<p>In Vue 3 everything changed. The core was rewritten from scratch and reactivity is now powered by Javascript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxies</a>. Proxies are a modern and elegant way to observe an object and get notified when a property is accessed or\u00a0updated.</p>\n<p>You can understand how proxies work with the following simple\u00a0example:</p>\n<pre>const userInfo = {<br>  firstName: \"fotis\",<br>  age: 35,<br>};<br><br>const handler = {<br>  get(target, property) {<br>    if (property === \"firstName\") {<br>      const name = target[property]<br>      return name.charAt(0).toUpperCase() + name.slice(1);<br>    }<br>    if (property === \"age\") {<br>      return '--'<br>    }<br>    return target[property]<br>  },<br>};<br><br>const proxy = new Proxy(userInfo, handler);<br><br>console.log(proxy.firstName) // \"Fotis\"<br>console.log(proxy.age) // \"--\"</pre>\n<p>The get method inside the handler is called a trap and will be called every time a property of the object is accessed.</p>\n<p>In a similar manner, a set trap can be\u00a0defined:</p>\n<pre>const userInfo = {<br>  firstName: \"Fotis\",<br>  age: 35,<br>};<br><br>const handler = {<br>  set(target, prop, value) {<br>    if (prop === \"age\") {<br>      if (!Number.isInteger(value)) {<br>        throw new TypeError(\"The age is not an integer\");<br>      }<br>      if (value &gt; 200) {<br>        throw new RangeError(\"The age seems invalid\");<br>      }<br>    }<br>    target[prop] = value;<br>    return true;<br>  },<br>};<br><br>const proxy = new Proxy(userInfo, handler);<br><br>proxy.age = 12 // OK<br>proxy.age = 300 // Error: The age seems invalid</pre>\n<p>This is exactly the idea behind Vue 3 reactivity. When a variable is declared using the reactive helper, a proxy is used to keep track of any\u00a0changes.</p>\n<pre>function reactive(obj) {<br>  return new Proxy(obj, {<br>    get(target, key) {<br>      track(target, key)<br>      return target[key]<br>    },<br>    set(target, key, value) {<br>      target[key] = value<br>      trigger(target, key)<br>    }<br>  })<br>}</pre>\n<blockquote>Of course, the actual <a href=\"https://github.com/vuejs/core/blob/main/packages/reactivity/src/reactive.ts#L83\">implementation of the reactive helper</a> is more sophisticated and handles edge cases but at the core it still uses <a href=\"https://github.com/vuejs/core/blob/main/packages/reactivity/src/reactive.ts#L279-L282\">a\u00a0proxy</a>.</blockquote>\n<p>The snippet above explains why destructuring or reassigning a reactive variable to a local variable is no longer reactive because it no longer triggers the get/set proxy traps on the source\u00a0object.</p>\n<p>This looks like a perfect solution to make everything reactive. But there is a catch! By definition, <strong>proxies only work for complex types</strong>. These are Objects, Arrays, Maps and Sets. To make a primitive reactive we still use a Proxy but we have to wrap it in an Object\u00a0first.</p>\n<pre>function ref(value) {<br>  const refObject = {<br>    get value() {<br>      track(refObject, 'value')<br>      return value<br>    },<br>    set value(newValue) {<br>      value = newValue<br>      trigger(refObject, 'value')<br>    }<br>  }<br>  return refObject<br>}</pre>\n<p>This explains the annoying\u00a0.value that has to be used inside script setup. And again restructuring or reassignment to a local variable doesn\u2019t\u00a0work.</p>\n<ul>\n<li><a href=\"https://vuejs.org/guide/extras/reactivity-in-depth.html\">Vue 3 Reactivity in\u00a0depth</a></li>\n<li><a href=\"https://github.com/vuejs/core/blob/main/packages/reactivity/src/reactive.ts\">Vue 3 reactivity source\u00a0code</a></li>\n</ul>\n<h3>Conclusion</h3>\n<p>So the answer to why both Ref and Reactive are needed is: <em>Proxies</em>. For complex types, they can be used directly but on primitives, a proxy object needs to be\u00a0created.</p>\n<p>Hopefully, understanding how Vue works under the hood can make you more effective and can clear any confusion between ref and reactive.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=344bb5da2593\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "vuejs",
              "vue",
              "front-end-development",
              "javascript",
              "web-development"
          ]
      },
      {
          "title": "How to Become a Book Technical Reviewer",
          "pubDate": "2023-07-05 19:13:50",
          "link": "https://fadamakis.medium.com/becoming-a-book-technical-reviewer-b0f2fd55f307?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/b0f2fd55f307",
          "author": "Fotis Adamakis",
          "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*hmkEsw2lBGoNv7J2r--KUg.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hmkEsw2lBGoNv7J2r--KUg.png\"></figure><p>Just got in my hands a very special book. Special because it is the very first book I was involved as a Technical Reviewer. About six months ago, during my first involvement with this project, I tried searching for information about the role and responsibilities of a Technical Reviewer. Unfortunately, my research was not successful since the available information online is limited and I didn't have someone in my circle to guide\u00a0me.</p>\n<p>So this is why, I\u2019m writing everything I wish I had known before starting on this\u00a0journey.</p>\n<h3>Understanding the\u00a0Role</h3>\n<p>The duty of the Technical Reviewer is to <strong>ensure the</strong> <strong>technical accuracy</strong> <strong>of the content</strong>, identify its strengths and areas for improvement, and offer suggestions. In essence, the role is that of an <strong>expert providing insightful feedback</strong> on the content. It's up to you to ensure that the content is technically accurate and up to date and that the code snippets make sense, enhance the reading experience, and actually work as expected.</p>\n<p>You also serve as a <strong>proxy-reader</strong>, representing the perspective of the intended audience. Your expertise and feedback play a vital role in shaping the final form of the\u00a0book.</p>\n<h3>The Review\u00a0Process</h3>\n<p>The process is quite simple and straightforward. Once the author has written a chapter, the Project Manager shares the chapter with you. You would have a couple of days (usually 3 days per chapter) to share your feedback on the chapter, which would then be shared with the author. It is basically an on-going review process during the development of the\u00a0book.</p>\n<p>The chapter drafts were shared in the form of a Word doc, where you can mark comments on the chapters. A Questionnaire would also be shared with you where you can mention your overall feedback for each\u00a0chapter.</p>\n<h3>Providing Constructive Feedback</h3>\n<p>As an expert, constructive and quality feedback is expected for every chapter. Here are some tips to make the process easier for\u00a0you</p>\n<ol>\n<li>Be <strong>specific</strong> and <strong>clear</strong>: When offering feedback, be specific about what worked well and what could be improved. Use simple and clear language to express your suggestions, making it easier for the author to implement changes.</li>\n<li>Offer <strong>actionable suggestions</strong>: Instead of just pointing out flaws, provide actionable suggestions for improvement. Offer alternative approaches, examples, or additional resources that can enhance the chapter\u2019s content or make it more engaging for\u00a0readers.</li>\n<li>Maintain a <strong>constructive and supportive tone</strong>: Remember to deliver feedback in a constructive and supportive manner. Focus on helping the author improve rather than criticizing their work. By providing encouragement alongside constructive suggestions, you can create a positive working relationship.</li>\n<li>Review the code and verify that it functions as expected, paying attention to details, such as accuracy, efficiency, and following coding standards. A bug on production can be reverted, a printed bug will be there\u00a0forever!</li>\n</ol>\n<p>Some examples from my reviews are the following. The suggestion mode of Word documents can help to keep track of the changes and add comments when\u00a0needed.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VZrvYMLkcQ6WqwF_koV68Q.png\"></figure><p>Of course, adding a link to the documentation to back up your claim is always a good\u00a0idea.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZQfboMdagqRVhf1ZAL3SRA.png\"></figure><p>In total, I was usually writing 2 to 10 comments per page. In some theoretical chapters, I had little to contribute but for some heavy code ones, a more throughout review was needed and the three days were not\u00a0enough.</p>\n<h3>Chapter questionnaire</h3>\n<p>In addition to reviewing each chapter, you will be required to complete a questionnaire consisting of the following 10 questions:</p>\n<ol>\n<li>\n<em>What were the highlights of this chapter?</em> <em>Will it give the reader practical skills?</em>\n</li>\n<li><em>Will the reader find it easy to follow the\u00a0chapter?</em></li>\n<li><em>What would you like to see less of in the\u00a0chapter?</em></li>\n<li><em>What could the author do to make the chapter more interesting?</em></li>\n<li><em>What important topics does the author leave uncovered, if any? Does the chapter leave you asking nagging questions?</em></li>\n<li><em>Does the reader learn to do enough in the chapter? What else should the chapter teach readers to\u00a0do?</em></li>\n<li><em>Where do you think readers will struggle in this chapter? What can the author do to address this\u00a0issue?</em></li>\n<li><em>Does the author explain the main important concepts clearly? Are there other important concepts and facts about the topic that should be covered in the\u00a0chapter?</em></li>\n<li><em>Are all of the code and the instructions given in the chapter accurate and functional? If not, please provide the solution in your feedback.</em></li>\n<li><em>Give an overall rating to the chapter out of\u00a010.</em></li>\n</ol>\n<p>This questionnaire provides an opportunity to provide additional feedback, ensuring that the strengths are acknowledged and the weaknesses are appropriately addressed.</p>\n<h3>Compensation \ud83d\udcb5</h3>\n<p>Apparently, you can make <a href=\"https://www.glassdoor.com/Salaries/technical-reviewer-salary-SRCH_KO0,18.htm\">good money</a> as a book technical reviewer. But this was not the case for me. I was not motivated by money and that\u2019s why I did this <em>almost</em> for free. That being said I did get invaluable insights into the book development process that I hope I can use someday to become a book author myself. The process was hard but I still want to go through with\u00a0it.</p>\n<p>To be fair I did get some actual rewards at the end of the\u00a0process.</p>\n<ul>\n<li>An eBook and a print copy of the\u00a0book</li>\n<li>12 Months packt subscription ($129.99)</li>\n<li>My name and a short biography were added to the credits page of the book and all relevant published materials</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/541/1*yzu7IraiLx94-3EqqsvecQ.png\"></figure><h3>Conclusion</h3>\n<p>Becoming a Book Technical Reviewer is a great opportunity to gain valuable insights into the book authoring process. Your role is to ensure technical accuracy, identify strengths and areas for improvement, and offer actionable suggestions that will shape the final version of the book. Although the review process requires time and commitment, it is a unique experience that I highly recommend.</p>\n<blockquote>If you are into Vue.js the book is called <a href=\"https://www.packtpub.com/product/vuejs-3-design-patterns-and-best-practices/9781803238074\">Vue.js 3 Design Patterns and Best Practices</a>. Let me know in the comments if you liked\u00a0it.</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b0f2fd55f307\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hmkEsw2lBGoNv7J2r--KUg.png\"></figure><p>Just got in my hands a very special book. Special because it is the very first book I was involved as a Technical Reviewer. About six months ago, during my first involvement with this project, I tried searching for information about the role and responsibilities of a Technical Reviewer. Unfortunately, my research was not successful since the available information online is limited and I didn't have someone in my circle to guide\u00a0me.</p>\n<p>So this is why, I\u2019m writing everything I wish I had known before starting on this\u00a0journey.</p>\n<h3>Understanding the\u00a0Role</h3>\n<p>The duty of the Technical Reviewer is to <strong>ensure the</strong> <strong>technical accuracy</strong> <strong>of the content</strong>, identify its strengths and areas for improvement, and offer suggestions. In essence, the role is that of an <strong>expert providing insightful feedback</strong> on the content. It's up to you to ensure that the content is technically accurate and up to date and that the code snippets make sense, enhance the reading experience, and actually work as expected.</p>\n<p>You also serve as a <strong>proxy-reader</strong>, representing the perspective of the intended audience. Your expertise and feedback play a vital role in shaping the final form of the\u00a0book.</p>\n<h3>The Review\u00a0Process</h3>\n<p>The process is quite simple and straightforward. Once the author has written a chapter, the Project Manager shares the chapter with you. You would have a couple of days (usually 3 days per chapter) to share your feedback on the chapter, which would then be shared with the author. It is basically an on-going review process during the development of the\u00a0book.</p>\n<p>The chapter drafts were shared in the form of a Word doc, where you can mark comments on the chapters. A Questionnaire would also be shared with you where you can mention your overall feedback for each\u00a0chapter.</p>\n<h3>Providing Constructive Feedback</h3>\n<p>As an expert, constructive and quality feedback is expected for every chapter. Here are some tips to make the process easier for\u00a0you</p>\n<ol>\n<li>Be <strong>specific</strong> and <strong>clear</strong>: When offering feedback, be specific about what worked well and what could be improved. Use simple and clear language to express your suggestions, making it easier for the author to implement changes.</li>\n<li>Offer <strong>actionable suggestions</strong>: Instead of just pointing out flaws, provide actionable suggestions for improvement. Offer alternative approaches, examples, or additional resources that can enhance the chapter\u2019s content or make it more engaging for\u00a0readers.</li>\n<li>Maintain a <strong>constructive and supportive tone</strong>: Remember to deliver feedback in a constructive and supportive manner. Focus on helping the author improve rather than criticizing their work. By providing encouragement alongside constructive suggestions, you can create a positive working relationship.</li>\n<li>Review the code and verify that it functions as expected, paying attention to details, such as accuracy, efficiency, and following coding standards. A bug on production can be reverted, a printed bug will be there\u00a0forever!</li>\n</ol>\n<p>Some examples from my reviews are the following. The suggestion mode of Word documents can help to keep track of the changes and add comments when\u00a0needed.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VZrvYMLkcQ6WqwF_koV68Q.png\"></figure><p>Of course, adding a link to the documentation to back up your claim is always a good\u00a0idea.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZQfboMdagqRVhf1ZAL3SRA.png\"></figure><p>In total, I was usually writing 2 to 10 comments per page. In some theoretical chapters, I had little to contribute but for some heavy code ones, a more throughout review was needed and the three days were not\u00a0enough.</p>\n<h3>Chapter questionnaire</h3>\n<p>In addition to reviewing each chapter, you will be required to complete a questionnaire consisting of the following 10 questions:</p>\n<ol>\n<li>\n<em>What were the highlights of this chapter?</em> <em>Will it give the reader practical skills?</em>\n</li>\n<li><em>Will the reader find it easy to follow the\u00a0chapter?</em></li>\n<li><em>What would you like to see less of in the\u00a0chapter?</em></li>\n<li><em>What could the author do to make the chapter more interesting?</em></li>\n<li><em>What important topics does the author leave uncovered, if any? Does the chapter leave you asking nagging questions?</em></li>\n<li><em>Does the reader learn to do enough in the chapter? What else should the chapter teach readers to\u00a0do?</em></li>\n<li><em>Where do you think readers will struggle in this chapter? What can the author do to address this\u00a0issue?</em></li>\n<li><em>Does the author explain the main important concepts clearly? Are there other important concepts and facts about the topic that should be covered in the\u00a0chapter?</em></li>\n<li><em>Are all of the code and the instructions given in the chapter accurate and functional? If not, please provide the solution in your feedback.</em></li>\n<li><em>Give an overall rating to the chapter out of\u00a010.</em></li>\n</ol>\n<p>This questionnaire provides an opportunity to provide additional feedback, ensuring that the strengths are acknowledged and the weaknesses are appropriately addressed.</p>\n<h3>Compensation \ud83d\udcb5</h3>\n<p>Apparently, you can make <a href=\"https://www.glassdoor.com/Salaries/technical-reviewer-salary-SRCH_KO0,18.htm\">good money</a> as a book technical reviewer. But this was not the case for me. I was not motivated by money and that\u2019s why I did this <em>almost</em> for free. That being said I did get invaluable insights into the book development process that I hope I can use someday to become a book author myself. The process was hard but I still want to go through with\u00a0it.</p>\n<p>To be fair I did get some actual rewards at the end of the\u00a0process.</p>\n<ul>\n<li>An eBook and a print copy of the\u00a0book</li>\n<li>12 Months packt subscription ($129.99)</li>\n<li>My name and a short biography were added to the credits page of the book and all relevant published materials</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/541/1*yzu7IraiLx94-3EqqsvecQ.png\"></figure><h3>Conclusion</h3>\n<p>Becoming a Book Technical Reviewer is a great opportunity to gain valuable insights into the book authoring process. Your role is to ensure technical accuracy, identify strengths and areas for improvement, and offer actionable suggestions that will shape the final version of the book. Although the review process requires time and commitment, it is a unique experience that I highly recommend.</p>\n<blockquote>If you are into Vue.js the book is called <a href=\"https://www.packtpub.com/product/vuejs-3-design-patterns-and-best-practices/9781803238074\">Vue.js 3 Design Patterns and Best Practices</a>. Let me know in the comments if you liked\u00a0it.</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b0f2fd55f307\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "web-development",
              "writing-tips",
              "programming",
              "front-end-development",
              "writing"
          ]
      },
      {
          "title": "The Anatomy of a Vue 3 Component",
          "pubDate": "2023-09-02 12:33:39",
          "link": "https://fadamakis.medium.com/the-anatomy-of-a-vue-3-component-285eadadea89?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/285eadadea89",
          "author": "Fotis Adamakis",
          "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*5JViuWS53KXxZV52zoEw3w.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5JViuWS53KXxZV52zoEw3w.png\"></figure><p>Vue 3 has made significant progress and reached a strong level of maturity with Composition API &amp; Script Setup being the recommended and widely adopted syntax for writing our components. This differs from the options API, which was the preferred approach in Vue\u00a02.</p>\n<p>Let's explore together all the ingredients of a Vue 3 component using Composition API and Script\u00a0Setup.</p>\n<p><strong>tl;dr \ud83d\udc47</strong></p>\n<pre>&lt;script setup&gt;<br>import {<br>  ref,<br>  reactive,<br>  defineAsyncComponent,<br>  computed,<br>  watch,<br>  onMounted,<br>} from \"vue\";<br><br>import useComposable from \"./composables/useComposable.js\";<br>import TheComponent from \"./components/TheComponent.vue\";<br><br>const AsyncComponent = defineAsyncComponent(() =&gt;<br>  import(\"./components/AsyncComponent.vue\")<br>);<br><br>console.log(\"Equivalent to created hook\");<br>onMounted(() =&gt; {<br>  console.log(\"Mounted hook called\");<br>});<br><br>const enabled = ref(true);<br>const data = reactive({ variable: false });<br><br>const props = defineProps({<br>  elements: Array,<br>  counter: {<br>    type: Number,<br>    default: 0,<br>  },<br>});<br><br>const { composableData, composableMethod } = useComposable();<br><br>const isEmpty = computed(() =&gt; {<br>  return props.counter === 0;<br>});<br><br>watch(props.counter, () =&gt; {<br>  console.log(\"Counter value changed\");<br>});<br><br>const emit = defineEmits([\"event-name\"]);<br>function emitEvent() {<br>  emit(\"event-name\");<br>}<br><br>function getParam(param) {<br>  return param;<br>}<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=\"wrapper\"&gt;<br>    &lt;TheComponent /&gt;<br>    &lt;AsyncComponent v-if=\"data.variable\" /&gt;<br>    &lt;div<br>      class=\"static-class-name\"<br>      :class=\"{ 'dynamic-class-name': data.variable }\"<br>    &gt;<br>      Dynamic attributes example<br>    &lt;/div&gt;<br>    &lt;button @click=\"emitEvent\"&gt;Emit event&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.wrapper {<br>  font-size: 20px;<br>}<br>&lt;/style&gt;</pre>\n<h3>Script Setup</h3>\n<p>A Single File Component still consists of 3 parts. The template, the styles and the script. The two former are almost identical between vue 2 and vue 3, with the latter being completely revamped to the so-called script setup syntax. Declararion is simply adding the setup keyword in the script\u00a0tag.</p>\n<pre>&lt;script setup&gt;<br>// Component logic goes here<br>// --<br>// Every variable and method<br>// will be automatically available <br>// in the template<br>&lt;/script&gt;</pre>\n<p>By doing so a lot of boilerplate can be removed because every variable and method declared inside the script setup, will be <strong>automatically</strong> available in the template.</p>\n<pre>&lt;script setup&gt;<br>const text = \"Hello world!\"<br><br>function getParam(param) {<br>  return param;<br>}<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  {{ text }}<br>  {{ getParam(1) }}<br>&lt;/template&gt;</pre>\n<h4>Reactive Data Declaration</h4>\n<p>A variable declared with the keyword const, let or var is not automatically reactive. To make it reactive we need to declare it using one of the following helpers.</p>\n<ul>\n<li>\n<a href=\"https://vuejs.org/api/reactivity-core.html#reactive\"><strong><em>reactive</em></strong></a><em> for complex types (Arrays, Objects, Maps,\u00a0Sets)</em>\n</li>\n<li>\n<a href=\"https://vuejs.org/api/reactivity-core.html#ref\"><strong><em>ref</em></strong></a><em> for primitives (String, Number,\u00a0Boolean)</em>\n</li>\n</ul>\n<pre>import { ref, reactive } from 'vue'<br><br>const enabled = ref(true)<br>const data = reactive({ variable: false })</pre>\n<blockquote><a href=\"https://medium.com/@fadamakis/vue-3-why-both-ref-and-reactive-are-needed-344bb5da2593\">More info about why both ref and reactive are\u00a0needed</a></blockquote>\n<h4>Component Declaration</h4>\n<p>Simply importing a component will make it available in the template. In the case of a lazy-loaded component, the defineAsyncComponent should be\u00a0used.</p>\n<pre>import { defineAsyncComponent } from \"vue\";<br>import TheComponent from \"./components/TheComponent.vue\";<br>const AsyncComponent = defineAsyncComponent(() =&gt;<br>  import(\"./components/AsyncComponent.vue\")<br>);</pre>\n<h4>Computed</h4>\n<p>Computed values work the same but the syntax is quite different. Declaration is done using the computed helper that accepts a callback and returns the reactive variable.</p>\n<pre>import { computed } from \"vue\";<br><br>const count = 0;<br><br>const isNegative = computed(() =&gt; {<br>  return count &lt; 0;<br>});</pre>\n<h4>Watcher</h4>\n<p>A watcher can be declared in a similar manner, accepting as a parameter a source and a callback. The <strong>source</strong> can be one of the following:</p>\n<ul>\n<li>A getter function or a computed that returns a\u00a0value</li>\n<li>A ref</li>\n<li>A reactive\u00a0object</li>\n<li>An array of any of the\u00a0above</li>\n</ul>\n<pre>import { watch, ref } from \"vue\";<br>const counter = ref(0);<br>watch(counter, () =&gt; {<br>  console.log(\"Counter value changed\");<br>});</pre>\n<h4>WatchEffect</h4>\n<p>WatchEffect, behaves like a watch but only expects a callback. The sources that will trigger the effect are automatically detected.</p>\n<pre>import { reactive, watchEffect } from \"vue\"<br><br>const state = reactive({<br> count: 0,<br> name: 'Leo'<br>})<br><br>watchEffect(() =&gt; {<br> // Runs immediately<br> // Logs \"Count: 0, Name: Leo\"<br> console.log(`Count: ${state.count}, Name: ${state.name}`)<br>})<br><br>state.count++ // logs \"Count: 1, Name: Leo\"<br>state.name = 'Cristiano' // logs \"Count: 1, Name: Cristiano\"</pre>\n<blockquote><a href=\"https://fadamakis.com/vue-3-watcheffect-is-impressive-but-watch-is-still-the-best-choice-8903b62fdc19\">More info about watch Vs watchEffect</a></blockquote>\n<h4>Lifecycle Hooks</h4>\n<p>A component has multiple lifecycle hooks that we can utilise according to our\u00a0needs:</p>\n<p><em>[onMounted, onUpdated, onUnmounted, onBeforeMount, onBeforeUpdate, onBeforeUnmount, onErrorCaptured, onRenderTracked, onRenderTriggered, onActivated, onDeactivated]</em></p>\n<p>The usage is as\u00a0follows:</p>\n<pre>import { onMounted } from \"vue\";<br>console.log(\"Equivalent to created hook\");<br>onMounted(() =&gt; {<br>  console.log(\"Mounted hook called\");<br>});</pre>\n<blockquote><a href=\"https://vuejs.org/api/composition-api-lifecycle.html\">More info about Lifecycle hooks</a></blockquote>\n<h4>Define Props</h4>\n<p>Props declaration is done with the defineProps script macro. Script macros don\u2019t need to be imported and the variableselements and counter in the following example will be automatically available in the template. All the <a href=\"https://vuejs.org/guide/components/props.html#prop-validation\">validation options</a> are supported.</p>\n<pre>defineProps({<br>  elements: Array,<br>  counter: {<br>    type: Number,<br>    default: 0,<br>  },<br>});</pre>\n<h4>Define Emits</h4>\n<p>Emits are declared with another script macro. First, we need to declare them with the defineEmits helper and then use the return value as the\u00a0emitter.</p>\n<pre>&lt;script setup&gt;<br>const emit = defineEmits([\"event-name\"]);<br>function emitEvent() {<br>  emit(\"event-name\");<br>}<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=\"emitEvent\"&gt;Emit event&lt;/button&gt;<br>&lt;/template&gt;</pre>\n<blockquote><a href=\"https://fadamakis.com/vue-3-script-setup-macros-ab754266363f\">More info about script setup\u00a0macros</a></blockquote>\n<h4>Composables</h4>\n<p>Composables are simple statefull functions that can be used to share data and logic between components. They replace mixins with a declarative and more easy to understand and test\u00a0syntax.</p>\n<p>A very basic example of a composable is the following:</p>\n<pre>// mouse.js<br>import { ref, onMounted, onUnmounted } from 'vue'<br><br>// by convention, composable function names start with \"use\"<br>export function useMouse() {<br>  // state encapsulated and managed by the composable<br>  const x = ref(0)<br>  const y = ref(0)<br><br>  // a composable can update its managed state over time.<br>  function update(event) {<br>    x.value = event.pageX<br>    y.value = event.pageY<br>  }<br><br>  // a composable can also hook into its owner component's<br>  // lifecycle to setup and teardown side effects.<br>  onMounted(() =&gt; window.addEventListener('mousemove', update))<br>  onUnmounted(() =&gt; window.removeEventListener('mousemove', update))<br><br>  // expose managed state as return value<br>  return { x, y }<br>}</pre>\n<pre>&lt;script setup&gt;<br>import { useMouse } from './mouse.js'<br><br>const { x, y } = useMouse()<br>&lt;/script&gt;<br><br>&lt;template&gt;Mouse position is at: {{ x }}, {{ y }}&lt;/template&gt;</pre>\n<blockquote><a href=\"https://fadamakis.com/why-mixins-are-considered-harmful-8d51a2709d2c\">Mixins vs Composables</a></blockquote>\n<h4>Additional Resources</h4>\n<ul>\n<li><a href=\"https://fadamakis.com/from-vue-2-options-api-to-vue-3-composition-api-fe6d6a738c2f\">Refactoring a Component from Vue 2 Options API to Vue 3 Composition API</a></li>\n<li><a href=\"https://fadamakis.com/vue-3-script-setup-cheat-sheet-36572c042128\">Vue 3 Script Setup Cheat\u00a0Sheet</a></li>\n<li><a href=\"https://fadamakis.com/vue-3-reactive-data-declaration-d17edc0a92e3\">Ref vs Reactive\u200a\u2014\u200aVue 3 Reactive Data Declaration</a></li>\n<li><a href=\"https://fadamakis.com/the-5-ways-to-define-a-component-in-vue-3-aeb01ac6f39f\">The <strong>5\u0336. 4 </strong>ways to Define a Component in Vue\u00a03</a></li>\n<li><a href=\"https://fadamakis.com/vue-3-function-expression-vs-function-declaration-inside-script-setup-7efc4ca05af0\">Function Expression Vs Function Declaration inside Script\u00a0Setup</a></li>\n<li><a href=\"https://fadamakis.com/10-mistakes-to-avoid-when-starting-with-vue-3-1d1ced8552ae\">10 Mistakes to Avoid When Starting with Vue\u00a03</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=P5BsTUQjvzQ&amp;t=4733s\">[Video] A Journey from Vue 2 Options API to Vue 3 Composition API</a></li>\n</ul>\n<p><a href=\"https://fadamakis.com/list/9e477cabb816\">Vue 3 - Composition API</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/285/1*TmMpARBrkbNkZS1wka-PrA.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=285eadadea89\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5JViuWS53KXxZV52zoEw3w.png\"></figure><p>Vue 3 has made significant progress and reached a strong level of maturity with Composition API &amp; Script Setup being the recommended and widely adopted syntax for writing our components. This differs from the options API, which was the preferred approach in Vue\u00a02.</p>\n<p>Let's explore together all the ingredients of a Vue 3 component using Composition API and Script\u00a0Setup.</p>\n<p><strong>tl;dr \ud83d\udc47</strong></p>\n<pre>&lt;script setup&gt;<br>import {<br>  ref,<br>  reactive,<br>  defineAsyncComponent,<br>  computed,<br>  watch,<br>  onMounted,<br>} from \"vue\";<br><br>import useComposable from \"./composables/useComposable.js\";<br>import TheComponent from \"./components/TheComponent.vue\";<br><br>const AsyncComponent = defineAsyncComponent(() =&gt;<br>  import(\"./components/AsyncComponent.vue\")<br>);<br><br>console.log(\"Equivalent to created hook\");<br>onMounted(() =&gt; {<br>  console.log(\"Mounted hook called\");<br>});<br><br>const enabled = ref(true);<br>const data = reactive({ variable: false });<br><br>const props = defineProps({<br>  elements: Array,<br>  counter: {<br>    type: Number,<br>    default: 0,<br>  },<br>});<br><br>const { composableData, composableMethod } = useComposable();<br><br>const isEmpty = computed(() =&gt; {<br>  return props.counter === 0;<br>});<br><br>watch(props.counter, () =&gt; {<br>  console.log(\"Counter value changed\");<br>});<br><br>const emit = defineEmits([\"event-name\"]);<br>function emitEvent() {<br>  emit(\"event-name\");<br>}<br><br>function getParam(param) {<br>  return param;<br>}<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=\"wrapper\"&gt;<br>    &lt;TheComponent /&gt;<br>    &lt;AsyncComponent v-if=\"data.variable\" /&gt;<br>    &lt;div<br>      class=\"static-class-name\"<br>      :class=\"{ 'dynamic-class-name': data.variable }\"<br>    &gt;<br>      Dynamic attributes example<br>    &lt;/div&gt;<br>    &lt;button @click=\"emitEvent\"&gt;Emit event&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.wrapper {<br>  font-size: 20px;<br>}<br>&lt;/style&gt;</pre>\n<h3>Script Setup</h3>\n<p>A Single File Component still consists of 3 parts. The template, the styles and the script. The two former are almost identical between vue 2 and vue 3, with the latter being completely revamped to the so-called script setup syntax. Declararion is simply adding the setup keyword in the script\u00a0tag.</p>\n<pre>&lt;script setup&gt;<br>// Component logic goes here<br>// --<br>// Every variable and method<br>// will be automatically available <br>// in the template<br>&lt;/script&gt;</pre>\n<p>By doing so a lot of boilerplate can be removed because every variable and method declared inside the script setup, will be <strong>automatically</strong> available in the template.</p>\n<pre>&lt;script setup&gt;<br>const text = \"Hello world!\"<br><br>function getParam(param) {<br>  return param;<br>}<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  {{ text }}<br>  {{ getParam(1) }}<br>&lt;/template&gt;</pre>\n<h4>Reactive Data Declaration</h4>\n<p>A variable declared with the keyword const, let or var is not automatically reactive. To make it reactive we need to declare it using one of the following helpers.</p>\n<ul>\n<li>\n<a href=\"https://vuejs.org/api/reactivity-core.html#reactive\"><strong><em>reactive</em></strong></a><em> for complex types (Arrays, Objects, Maps,\u00a0Sets)</em>\n</li>\n<li>\n<a href=\"https://vuejs.org/api/reactivity-core.html#ref\"><strong><em>ref</em></strong></a><em> for primitives (String, Number,\u00a0Boolean)</em>\n</li>\n</ul>\n<pre>import { ref, reactive } from 'vue'<br><br>const enabled = ref(true)<br>const data = reactive({ variable: false })</pre>\n<blockquote><a href=\"https://medium.com/@fadamakis/vue-3-why-both-ref-and-reactive-are-needed-344bb5da2593\">More info about why both ref and reactive are\u00a0needed</a></blockquote>\n<h4>Component Declaration</h4>\n<p>Simply importing a component will make it available in the template. In the case of a lazy-loaded component, the defineAsyncComponent should be\u00a0used.</p>\n<pre>import { defineAsyncComponent } from \"vue\";<br>import TheComponent from \"./components/TheComponent.vue\";<br>const AsyncComponent = defineAsyncComponent(() =&gt;<br>  import(\"./components/AsyncComponent.vue\")<br>);</pre>\n<h4>Computed</h4>\n<p>Computed values work the same but the syntax is quite different. Declaration is done using the computed helper that accepts a callback and returns the reactive variable.</p>\n<pre>import { computed } from \"vue\";<br><br>const count = 0;<br><br>const isNegative = computed(() =&gt; {<br>  return count &lt; 0;<br>});</pre>\n<h4>Watcher</h4>\n<p>A watcher can be declared in a similar manner, accepting as a parameter a source and a callback. The <strong>source</strong> can be one of the following:</p>\n<ul>\n<li>A getter function or a computed that returns a\u00a0value</li>\n<li>A ref</li>\n<li>A reactive\u00a0object</li>\n<li>An array of any of the\u00a0above</li>\n</ul>\n<pre>import { watch, ref } from \"vue\";<br>const counter = ref(0);<br>watch(counter, () =&gt; {<br>  console.log(\"Counter value changed\");<br>});</pre>\n<h4>WatchEffect</h4>\n<p>WatchEffect, behaves like a watch but only expects a callback. The sources that will trigger the effect are automatically detected.</p>\n<pre>import { reactive, watchEffect } from \"vue\"<br><br>const state = reactive({<br> count: 0,<br> name: 'Leo'<br>})<br><br>watchEffect(() =&gt; {<br> // Runs immediately<br> // Logs \"Count: 0, Name: Leo\"<br> console.log(`Count: ${state.count}, Name: ${state.name}`)<br>})<br><br>state.count++ // logs \"Count: 1, Name: Leo\"<br>state.name = 'Cristiano' // logs \"Count: 1, Name: Cristiano\"</pre>\n<blockquote><a href=\"https://fadamakis.com/vue-3-watcheffect-is-impressive-but-watch-is-still-the-best-choice-8903b62fdc19\">More info about watch Vs watchEffect</a></blockquote>\n<h4>Lifecycle Hooks</h4>\n<p>A component has multiple lifecycle hooks that we can utilise according to our\u00a0needs:</p>\n<p><em>[onMounted, onUpdated, onUnmounted, onBeforeMount, onBeforeUpdate, onBeforeUnmount, onErrorCaptured, onRenderTracked, onRenderTriggered, onActivated, onDeactivated]</em></p>\n<p>The usage is as\u00a0follows:</p>\n<pre>import { onMounted } from \"vue\";<br>console.log(\"Equivalent to created hook\");<br>onMounted(() =&gt; {<br>  console.log(\"Mounted hook called\");<br>});</pre>\n<blockquote><a href=\"https://vuejs.org/api/composition-api-lifecycle.html\">More info about Lifecycle hooks</a></blockquote>\n<h4>Define Props</h4>\n<p>Props declaration is done with the defineProps script macro. Script macros don\u2019t need to be imported and the variableselements and counter in the following example will be automatically available in the template. All the <a href=\"https://vuejs.org/guide/components/props.html#prop-validation\">validation options</a> are supported.</p>\n<pre>defineProps({<br>  elements: Array,<br>  counter: {<br>    type: Number,<br>    default: 0,<br>  },<br>});</pre>\n<h4>Define Emits</h4>\n<p>Emits are declared with another script macro. First, we need to declare them with the defineEmits helper and then use the return value as the\u00a0emitter.</p>\n<pre>&lt;script setup&gt;<br>const emit = defineEmits([\"event-name\"]);<br>function emitEvent() {<br>  emit(\"event-name\");<br>}<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=\"emitEvent\"&gt;Emit event&lt;/button&gt;<br>&lt;/template&gt;</pre>\n<blockquote><a href=\"https://fadamakis.com/vue-3-script-setup-macros-ab754266363f\">More info about script setup\u00a0macros</a></blockquote>\n<h4>Composables</h4>\n<p>Composables are simple statefull functions that can be used to share data and logic between components. They replace mixins with a declarative and more easy to understand and test\u00a0syntax.</p>\n<p>A very basic example of a composable is the following:</p>\n<pre>// mouse.js<br>import { ref, onMounted, onUnmounted } from 'vue'<br><br>// by convention, composable function names start with \"use\"<br>export function useMouse() {<br>  // state encapsulated and managed by the composable<br>  const x = ref(0)<br>  const y = ref(0)<br><br>  // a composable can update its managed state over time.<br>  function update(event) {<br>    x.value = event.pageX<br>    y.value = event.pageY<br>  }<br><br>  // a composable can also hook into its owner component's<br>  // lifecycle to setup and teardown side effects.<br>  onMounted(() =&gt; window.addEventListener('mousemove', update))<br>  onUnmounted(() =&gt; window.removeEventListener('mousemove', update))<br><br>  // expose managed state as return value<br>  return { x, y }<br>}</pre>\n<pre>&lt;script setup&gt;<br>import { useMouse } from './mouse.js'<br><br>const { x, y } = useMouse()<br>&lt;/script&gt;<br><br>&lt;template&gt;Mouse position is at: {{ x }}, {{ y }}&lt;/template&gt;</pre>\n<blockquote><a href=\"https://fadamakis.com/why-mixins-are-considered-harmful-8d51a2709d2c\">Mixins vs Composables</a></blockquote>\n<h4>Additional Resources</h4>\n<ul>\n<li><a href=\"https://fadamakis.com/from-vue-2-options-api-to-vue-3-composition-api-fe6d6a738c2f\">Refactoring a Component from Vue 2 Options API to Vue 3 Composition API</a></li>\n<li><a href=\"https://fadamakis.com/vue-3-script-setup-cheat-sheet-36572c042128\">Vue 3 Script Setup Cheat\u00a0Sheet</a></li>\n<li><a href=\"https://fadamakis.com/vue-3-reactive-data-declaration-d17edc0a92e3\">Ref vs Reactive\u200a\u2014\u200aVue 3 Reactive Data Declaration</a></li>\n<li><a href=\"https://fadamakis.com/the-5-ways-to-define-a-component-in-vue-3-aeb01ac6f39f\">The <strong>5\u0336. 4 </strong>ways to Define a Component in Vue\u00a03</a></li>\n<li><a href=\"https://fadamakis.com/vue-3-function-expression-vs-function-declaration-inside-script-setup-7efc4ca05af0\">Function Expression Vs Function Declaration inside Script\u00a0Setup</a></li>\n<li><a href=\"https://fadamakis.com/10-mistakes-to-avoid-when-starting-with-vue-3-1d1ced8552ae\">10 Mistakes to Avoid When Starting with Vue\u00a03</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=P5BsTUQjvzQ&amp;t=4733s\">[Video] A Journey from Vue 2 Options API to Vue 3 Composition API</a></li>\n</ul>\n<p><a href=\"https://fadamakis.com/list/9e477cabb816\">Vue 3 - Composition API</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/285/1*TmMpARBrkbNkZS1wka-PrA.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=285eadadea89\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "vuejs",
              "javascript",
              "vue",
              "web-development",
              "front-end-development"
          ]
      },
      {
          "title": "Integrating an Icon Library to a Vue Application",
          "pubDate": "2023-08-27 15:20:54",
          "link": "https://fadamakis.medium.com/integrating-an-icon-library-to-a-vue-application-b342fee12fae?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/b342fee12fae",
          "author": "Fotis Adamakis",
          "thumbnail": "https://miro.medium.com/v2/resize:fit:640/format:webp/1*aFVE_GMWYCHcIKe8fv9Uyw.png",
          "description": "\n<p>Icons are an essential part of any enterprise application. They can be used to represent actions, concepts or data and improve the overall user experience by adding visual flair and\u00a0clarity.</p>\n<p>There are many different icon libraries available. Some popular options include <a href=\"https://icons.getbootstrap.com/\">Bootstrap Icons</a>, <a href=\"https://fontawesome.com/\">Font Awesome</a>, <a href=\"https://icomoon.io/\">IcoMoon</a>, <a href=\"https://feathericons.com/\">Feather Icons</a>, <a href=\"https://www.npmjs.com/package/vue-material-design-icons\">Vue-Material</a>, and <a href=\"https://antonreshetov.github.io/vue-unicons/\">Vue-Unicons</a>. In this article, we will use <a href=\"https://icons.getbootstrap.com/\">Bootstrap Icons</a> as it is the most popular one, and they can be used independently without using the whole Bootstrap UI Library, but the integration would be similar for any other\u00a0option.</p>\n<h3>Installation</h3>\n<p>To add Bootstrap Icons to an existing project using npm paste the following in the terminal:</p>\n<pre>npm i bootstrap-icons</pre>\n<blockquote>\n<em>Alternative commands: </em><em>yarn add bootstrap-icons or </em><em>pnpm add bootstrap-icons</em>\n</blockquote>\n<blockquote>\n<em>If you dont have an existing application you can create a new one using </em>npm create vite@latest vue-icons\u200a\u2014\u200a\u2014 template\u00a0vue</blockquote>\n<p>There are <a href=\"https://icons.getbootstrap.com/?#embedded\">many different techniques</a> for integrating the library into our application like<strong> </strong>sprites, external image sources, icon fonts, inline embed and background image using CSS. We will use the <a href=\"https://www.sitepoint.com/use-svg-image-sprites/\">SVG sprite technique</a>.</p>\n<p>Let\u2019s create a component called AppIcon.vuewith the following contents:</p>\n<pre>&lt;!-- AppIcon.vue --&gt;<br><br>&lt;script setup&gt;<br>import BootstrapIcons from \"bootstrap-icons/bootstrap-icons.svg\";<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;svg width=\"32\" height=\"32\" fill=\"currentColor\"&gt;<br>    &lt;use v-bind:xlink:href=\"`${BootstrapIcons}#$shop`\" /&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;</pre>\n<p>The result is a 32-pixel shop\u00a0icon.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/118/1*fU-FiRHpnfx4Co6cbL01_g.png\"></figure><p>That was <em>easy</em>, but our component is not yet dynamic. We should be able to configure the image, colour and size of our icon. We can do this using\u00a0props.</p>\n<p>Let's start with the\u00a0image.</p>\n<p>Notice that in the example above we are importing the shop icon from the SVG sprite which has the following format:</p>\n<pre>&lt;svg&gt;<br>  &lt;defs&gt;<br>    &lt;g id=\"shop\"&gt;<br>      &lt;!-- all the paths and shapes for the shop icon --&gt;<br>    &lt;g&gt;<br>    &lt;g id=\"pencil\"&gt;<br>      &lt;!-- all the paths and shapes for the pencil icon --&gt;<br>    &lt;g&gt;<br>    &lt;!-- etc --&gt;<br>  &lt;/defs&gt;<br>&lt;/svg&gt;</pre>\n<p>Any of the <a href=\"https://icons.getbootstrap.com/?#icons\">available icons</a> of the library can be used. All we have to do is make that part dynamic using a\u00a0prop.</p>\n<pre>&lt;!-- AppIcon.vue --&gt;<br>&lt;script setup&gt;<br>import BootstrapIcons from \"bootstrap-icons/bootstrap-icons.svg\";<br><br>defineProps({<br>  icon: {<br>    type: String,<br>    required: true,<br>  },<br>});<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;svg width=\"32\" height=\"32\" fill=\"currentColor\"&gt;<br>    &lt;use v-bind:xlink:href=\"`${BootstrapIcons}#${icon}`\" /&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;</pre>\n<pre>&lt;!-- App.vue --&gt;<br>&lt;AppIcon icon=\"pencil\" /&gt;<br>&lt;AppIcon icon=\"medium\" /&gt;<br>&lt;AppIcon icon=\"send\" /&gt;</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/275/1*-UxcATNsyH51SszQqLEPnQ.png\"></figure><p>We can do the same for the colour if we want to restrict the available colours to a specific palette. If not, we can leverage fill as a <a href=\"https://vuejs.org/guide/components/attrs.html\">fallthrough attribute</a> for a cleaner approach.</p>\n<pre>&lt;!-- App.vue --&gt;<br>&lt;AppIcon icon=\"pencil\" fill=\"#45FFCA\" /&gt;<br>&lt;AppIcon icon=\"medium\" fill=\"#78C1F3\" /&gt;<br>&lt;AppIcon icon=\"send\" fill=\"#D67BFF\" /&gt;</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/218/1*Q-HAQ2tdZSzTNi3dzyXUuw.png\"></figure><p>Fall-through attributes would also work for the size, but it is common for sizes to be restricted to a list of predefined options. That\u2019s why we will use a prop, that will control a class which can be targeted with\u00a0CSS.</p>\n<pre><br>&lt;!-- AppIcon.vue --&gt;<br>&lt;script setup&gt;<br>import BootstrapIcons from \"bootstrap-icons/bootstrap-icons.svg\";<br><br>defineProps({<br>  icon: {<br>    type: String,<br>    required: true,<br>  },<br>  size: {<br>    type: String,<br>    default: 'md',<br>  },<br>});<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;svg class=\"icon\" :class=\"`icon-size-${size}`\"&gt;<br>    &lt;g transform-origin=\"center\"&gt;<br>      &lt;use v-bind:xlink:href=\"`${BootstrapIcons}#${icon}`\" /&gt;<br>    &lt;/g&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped lang=\"scss\"&gt;<br>.icon {<br>  width: 1em;<br>  height: 1em;<br>}<br>.icon-size {<br>  &amp;-sm {<br>    font-size: 0.75rem;<br>  }<br>  &amp;-md {<br>    font-size: 1rem;<br>  }<br>  &amp;-lg {<br>    font-size: 1.5rem;<br>  }<br>  &amp;-2x {<br>    font-size: 2rem;<br>  }<br>  &amp;-3x {<br>    font-size: 3rem;<br>  }<br>  &amp;-4x {<br>    font-size: 4rem;<br>  }<br>  &amp;-5x {<br>    font-size: 5rem;<br>  }<br>}<br>&lt;/style&gt;</pre>\n<blockquote>\n<a href=\"https://sass-lang.com/\">Sass</a> is used since its the intrustry standard, but CSS would also work. Installation with <em>npm install -D sass-loader sass</em>\n</blockquote>\n<p>We are using the <a href=\"https://css-tricks.com/control-icons-with-font-size/\">font-size SVG sizing technique</a> by setting the SVG width to 1em and controlling the size of each modifier using the font-size property. The specific font sizes can be adjusted to match your design\u00a0system.</p>\n<pre>&lt;!-- App.vue --&gt;<br>&lt;AppIcon icon=\"pencil\" fill=\"#45FFCA\" size=\"2x\" /&gt;<br>&lt;AppIcon icon=\"medium\" fill=\"#78C1F3\" size=\"4x\" /&gt;<br>&lt;AppIcon icon=\"send\" fill=\"#D67BFF\" size=\"lg\" /&gt;</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/267/1*JIif_85KQGjAbS0V-NNGtg.png\"></figure><h3>Adding TypeScript</h3>\n<p>Our component is now dynamic and works well but the following incorrect usage of the size prop is permitted.</p>\n<pre>&lt;AppIcon icon=\"send\" size=\"large\" /&gt;</pre>\n<p>We can <a href=\"https://stackoverflow.com/questions/63724523/how-to-add-typescript-to-vue-3-and-vite-project\">convert our component to TypeScript</a> and leverage an enum to prevent wrong\u00a0usage.</p>\n<pre>&lt;script setup lang=\"ts\"&gt;<br>import BootstrapIcons from \"bootstrap-icons/bootstrap-icons.svg\";<br>import { PropType } from \"vue\";<br><br>enum IconSizes {<br>  \"sm\",<br>  \"md\",<br>  \"lg\",<br>  \"2x\",<br>  \"3x\",<br>  \"4x\",<br>  \"5x\",<br>}<br><br>defineProps({<br>  icon: {<br>    type: String,<br>    required: true,<br>  },<br>  size: {<br>    type: String as PropType&lt;keyof typeof IconSizes&gt;,<br>    default: IconSizes.md,<br>  },<br>});<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;svg class=\"icon\" :class=\"`icon-size-${size}`\"&gt;<br>    &lt;g transform-origin=\"center\"&gt;<br>      &lt;use v-bind:xlink:href=\"`${BootstrapIcons}#${icon}`\" /&gt;<br>    &lt;/g&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped lang=\"scss\"&gt;<br>.icon {<br>  width: 1em;<br>  height: 1em;<br>}<br>.icon-size {<br>  &amp;-sm {<br>    font-size: 0.75rem;<br>  }<br>  &amp;-md {<br>    font-size: 1rem;<br>  }<br>  &amp;-lg {<br>    font-size: 1.5rem;<br>  }<br>  &amp;-2x {<br>    font-size: 2rem;<br>  }<br>  &amp;-3x {<br>    font-size: 3rem;<br>  }<br>  &amp;-4x {<br>    font-size: 4rem;<br>  }<br>  &amp;-5x {<br>    font-size: 5rem;<br>  }<br>}<br>&lt;/style&gt;</pre>\n<p>In case of a misusage, the IDE will warn us with a helpful\u00a0message.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/870/1*IZH9EN4gREBFkoANUsjfag.png\"></figure><h3>Conclusion</h3>\n<p>So here we go, a simple and reusable icon component that uses <a href=\"https://icons.getbootstrap.com/\">bootstrap-icons</a> sprite behind the scenes and encapsulates the complexity of icon\u00a0sizes.</p>\n<p>The code examples are available on\u00a0<a href=\"https://github.com/fadamakis/vue-icons/tree/main\">GitHub</a>.</p>\n<figure><a href=\"https://notbyai.fyi/\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/262/0*DC2B4SIaV3ZEXreV.png\"></a></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*aFVE_GMWYCHcIKe8fv9Uyw.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b342fee12fae\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<p>Icons are an essential part of any enterprise application. They can be used to represent actions, concepts or data and improve the overall user experience by adding visual flair and\u00a0clarity.</p>\n<p>There are many different icon libraries available. Some popular options include <a href=\"https://icons.getbootstrap.com/\">Bootstrap Icons</a>, <a href=\"https://fontawesome.com/\">Font Awesome</a>, <a href=\"https://icomoon.io/\">IcoMoon</a>, <a href=\"https://feathericons.com/\">Feather Icons</a>, <a href=\"https://www.npmjs.com/package/vue-material-design-icons\">Vue-Material</a>, and <a href=\"https://antonreshetov.github.io/vue-unicons/\">Vue-Unicons</a>. In this article, we will use <a href=\"https://icons.getbootstrap.com/\">Bootstrap Icons</a> as it is the most popular one, and they can be used independently without using the whole Bootstrap UI Library, but the integration would be similar for any other\u00a0option.</p>\n<h3>Installation</h3>\n<p>To add Bootstrap Icons to an existing project using npm paste the following in the terminal:</p>\n<pre>npm i bootstrap-icons</pre>\n<blockquote>\n<em>Alternative commands: </em><em>yarn add bootstrap-icons or </em><em>pnpm add bootstrap-icons</em>\n</blockquote>\n<blockquote>\n<em>If you dont have an existing application you can create a new one using </em>npm create vite@latest vue-icons\u200a\u2014\u200a\u2014 template\u00a0vue</blockquote>\n<p>There are <a href=\"https://icons.getbootstrap.com/?#embedded\">many different techniques</a> for integrating the library into our application like<strong> </strong>sprites, external image sources, icon fonts, inline embed and background image using CSS. We will use the <a href=\"https://www.sitepoint.com/use-svg-image-sprites/\">SVG sprite technique</a>.</p>\n<p>Let\u2019s create a component called AppIcon.vuewith the following contents:</p>\n<pre>&lt;!-- AppIcon.vue --&gt;<br><br>&lt;script setup&gt;<br>import BootstrapIcons from \"bootstrap-icons/bootstrap-icons.svg\";<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;svg width=\"32\" height=\"32\" fill=\"currentColor\"&gt;<br>    &lt;use v-bind:xlink:href=\"`${BootstrapIcons}#$shop`\" /&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;</pre>\n<p>The result is a 32-pixel shop\u00a0icon.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/118/1*fU-FiRHpnfx4Co6cbL01_g.png\"></figure><p>That was <em>easy</em>, but our component is not yet dynamic. We should be able to configure the image, colour and size of our icon. We can do this using\u00a0props.</p>\n<p>Let's start with the\u00a0image.</p>\n<p>Notice that in the example above we are importing the shop icon from the SVG sprite which has the following format:</p>\n<pre>&lt;svg&gt;<br>  &lt;defs&gt;<br>    &lt;g id=\"shop\"&gt;<br>      &lt;!-- all the paths and shapes for the shop icon --&gt;<br>    &lt;g&gt;<br>    &lt;g id=\"pencil\"&gt;<br>      &lt;!-- all the paths and shapes for the pencil icon --&gt;<br>    &lt;g&gt;<br>    &lt;!-- etc --&gt;<br>  &lt;/defs&gt;<br>&lt;/svg&gt;</pre>\n<p>Any of the <a href=\"https://icons.getbootstrap.com/?#icons\">available icons</a> of the library can be used. All we have to do is make that part dynamic using a\u00a0prop.</p>\n<pre>&lt;!-- AppIcon.vue --&gt;<br>&lt;script setup&gt;<br>import BootstrapIcons from \"bootstrap-icons/bootstrap-icons.svg\";<br><br>defineProps({<br>  icon: {<br>    type: String,<br>    required: true,<br>  },<br>});<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;svg width=\"32\" height=\"32\" fill=\"currentColor\"&gt;<br>    &lt;use v-bind:xlink:href=\"`${BootstrapIcons}#${icon}`\" /&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;</pre>\n<pre>&lt;!-- App.vue --&gt;<br>&lt;AppIcon icon=\"pencil\" /&gt;<br>&lt;AppIcon icon=\"medium\" /&gt;<br>&lt;AppIcon icon=\"send\" /&gt;</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/275/1*-UxcATNsyH51SszQqLEPnQ.png\"></figure><p>We can do the same for the colour if we want to restrict the available colours to a specific palette. If not, we can leverage fill as a <a href=\"https://vuejs.org/guide/components/attrs.html\">fallthrough attribute</a> for a cleaner approach.</p>\n<pre>&lt;!-- App.vue --&gt;<br>&lt;AppIcon icon=\"pencil\" fill=\"#45FFCA\" /&gt;<br>&lt;AppIcon icon=\"medium\" fill=\"#78C1F3\" /&gt;<br>&lt;AppIcon icon=\"send\" fill=\"#D67BFF\" /&gt;</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/218/1*Q-HAQ2tdZSzTNi3dzyXUuw.png\"></figure><p>Fall-through attributes would also work for the size, but it is common for sizes to be restricted to a list of predefined options. That\u2019s why we will use a prop, that will control a class which can be targeted with\u00a0CSS.</p>\n<pre><br>&lt;!-- AppIcon.vue --&gt;<br>&lt;script setup&gt;<br>import BootstrapIcons from \"bootstrap-icons/bootstrap-icons.svg\";<br><br>defineProps({<br>  icon: {<br>    type: String,<br>    required: true,<br>  },<br>  size: {<br>    type: String,<br>    default: 'md',<br>  },<br>});<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;svg class=\"icon\" :class=\"`icon-size-${size}`\"&gt;<br>    &lt;g transform-origin=\"center\"&gt;<br>      &lt;use v-bind:xlink:href=\"`${BootstrapIcons}#${icon}`\" /&gt;<br>    &lt;/g&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped lang=\"scss\"&gt;<br>.icon {<br>  width: 1em;<br>  height: 1em;<br>}<br>.icon-size {<br>  &amp;-sm {<br>    font-size: 0.75rem;<br>  }<br>  &amp;-md {<br>    font-size: 1rem;<br>  }<br>  &amp;-lg {<br>    font-size: 1.5rem;<br>  }<br>  &amp;-2x {<br>    font-size: 2rem;<br>  }<br>  &amp;-3x {<br>    font-size: 3rem;<br>  }<br>  &amp;-4x {<br>    font-size: 4rem;<br>  }<br>  &amp;-5x {<br>    font-size: 5rem;<br>  }<br>}<br>&lt;/style&gt;</pre>\n<blockquote>\n<a href=\"https://sass-lang.com/\">Sass</a> is used since its the intrustry standard, but CSS would also work. Installation with <em>npm install -D sass-loader sass</em>\n</blockquote>\n<p>We are using the <a href=\"https://css-tricks.com/control-icons-with-font-size/\">font-size SVG sizing technique</a> by setting the SVG width to 1em and controlling the size of each modifier using the font-size property. The specific font sizes can be adjusted to match your design\u00a0system.</p>\n<pre>&lt;!-- App.vue --&gt;<br>&lt;AppIcon icon=\"pencil\" fill=\"#45FFCA\" size=\"2x\" /&gt;<br>&lt;AppIcon icon=\"medium\" fill=\"#78C1F3\" size=\"4x\" /&gt;<br>&lt;AppIcon icon=\"send\" fill=\"#D67BFF\" size=\"lg\" /&gt;</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/267/1*JIif_85KQGjAbS0V-NNGtg.png\"></figure><h3>Adding TypeScript</h3>\n<p>Our component is now dynamic and works well but the following incorrect usage of the size prop is permitted.</p>\n<pre>&lt;AppIcon icon=\"send\" size=\"large\" /&gt;</pre>\n<p>We can <a href=\"https://stackoverflow.com/questions/63724523/how-to-add-typescript-to-vue-3-and-vite-project\">convert our component to TypeScript</a> and leverage an enum to prevent wrong\u00a0usage.</p>\n<pre>&lt;script setup lang=\"ts\"&gt;<br>import BootstrapIcons from \"bootstrap-icons/bootstrap-icons.svg\";<br>import { PropType } from \"vue\";<br><br>enum IconSizes {<br>  \"sm\",<br>  \"md\",<br>  \"lg\",<br>  \"2x\",<br>  \"3x\",<br>  \"4x\",<br>  \"5x\",<br>}<br><br>defineProps({<br>  icon: {<br>    type: String,<br>    required: true,<br>  },<br>  size: {<br>    type: String as PropType&lt;keyof typeof IconSizes&gt;,<br>    default: IconSizes.md,<br>  },<br>});<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;svg class=\"icon\" :class=\"`icon-size-${size}`\"&gt;<br>    &lt;g transform-origin=\"center\"&gt;<br>      &lt;use v-bind:xlink:href=\"`${BootstrapIcons}#${icon}`\" /&gt;<br>    &lt;/g&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped lang=\"scss\"&gt;<br>.icon {<br>  width: 1em;<br>  height: 1em;<br>}<br>.icon-size {<br>  &amp;-sm {<br>    font-size: 0.75rem;<br>  }<br>  &amp;-md {<br>    font-size: 1rem;<br>  }<br>  &amp;-lg {<br>    font-size: 1.5rem;<br>  }<br>  &amp;-2x {<br>    font-size: 2rem;<br>  }<br>  &amp;-3x {<br>    font-size: 3rem;<br>  }<br>  &amp;-4x {<br>    font-size: 4rem;<br>  }<br>  &amp;-5x {<br>    font-size: 5rem;<br>  }<br>}<br>&lt;/style&gt;</pre>\n<p>In case of a misusage, the IDE will warn us with a helpful\u00a0message.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/870/1*IZH9EN4gREBFkoANUsjfag.png\"></figure><h3>Conclusion</h3>\n<p>So here we go, a simple and reusable icon component that uses <a href=\"https://icons.getbootstrap.com/\">bootstrap-icons</a> sprite behind the scenes and encapsulates the complexity of icon\u00a0sizes.</p>\n<p>The code examples are available on\u00a0<a href=\"https://github.com/fadamakis/vue-icons/tree/main\">GitHub</a>.</p>\n<figure><a href=\"https://notbyai.fyi/\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/262/0*DC2B4SIaV3ZEXreV.png\"></a></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*aFVE_GMWYCHcIKe8fv9Uyw.png\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b342fee12fae\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "web-development",
              "vuejs",
              "bootstrap",
              "java",
              "icons"
          ]
      },
      {
          "title": "15 Terrible Advice for Web Developers",
          "pubDate": "2023-08-21 19:01:07",
          "link": "https://fadamakis.medium.com/15-terrible-advice-for-web-developers-e821e95f5d18?source=rss-ba9bef041285------2",
          "guid": "https://medium.com/p/e821e95f5d18",
          "author": "Fotis Adamakis",
          "thumbnail": "https://cdn-images-1.medium.com/max/1024/0*lQ0kEv6S8f1VWfaD.jpg",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*lQ0kEv6S8f1VWfaD.jpg\"></figure><p>Medium is full of useful articles and great advice to create robust and maintainable applications. But what If you don't like your colleagues and want to ruin their day? Then worry no more. I\u2019m great at giving bad advice and came up with 15 tips to cause frustration and waste everyone's time.</p>\n<h3>1. Abstraction Layers</h3>\n<p>Use as many abstraction layers as possible\u00a0until:</p>\n<ul>\n<li>The code is difficult to understand and\u00a0debug.</li>\n<li>It is difficult to make changes to the\u00a0code.</li>\n<li>The code is slow or inefficient.</li>\n<li>The code is not reusable.</li>\n</ul>\n<h3>2. Always Request Changes on Pull\u00a0Requests</h3>\n<p>You should always block a pull request during the first review to assert dominance.</p>\n<p>Some ideas for change requests\u00a0are:</p>\n<ul>\n<li>Make a variable name\u00a0longer</li>\n<li>Make a variable name\u00a0shorter</li>\n<li>Rename a variable\u00a0name</li>\n<li>Make code more\u00a0<em>DRY</em>\n</li>\n</ul>\n<h3>3. No Commit\u00a0Messages</h3>\n<p><a href=\"https://cbea.ms/git-commit/\">Good commit messages</a> take time to write. Instead of spending your valuable time writing something like</p>\n<p>[JIRA-1234] build: replace vue-cli with\u00a0vite</p>\n<p>you can use the following command to push your code with an empty commit\u00a0message</p>\n<p>git commit --allow-empty-message -m \"\" &amp;&amp; git push\u00a0--force</p>\n<h3>4. Use Magic\u00a0Numbers</h3>\n<p>Use magic numbers often to indicate that you know <strong><em>exactly</em></strong> what you are\u00a0doing</p>\n<pre>window.scrollTo({<br>  top: 89,<br>  left: 12,<br>  behavior: \"smooth\",<br>});</pre>\n<h3>5. Mix Return Statements</h3>\n<p>Never let them know your next move by mixing the return statements of a\u00a0function</p>\n<pre>function shouldPayTax(income) {<br>  if(income.amount &lt; 20_000) {<br>    return false<br>  }<br>  if(income.amount &gt; 20_000 &amp;&amp; income.country == 'USA') {<br>    return true<br>  }<br>  if(income.country == 'Panama') {<br>    return false<br>  }<br>  if(this.totalWorkingHoursPerWeek &gt; 60) {<br>    return true<br>  }<br>  if(income.amount &gt; 20_000 &amp;&amp; income.isCelebrity == true) {<br>    return false<br>  }<br>  if(income.amount &gt; 20_000) {<br>    return true<br>  }<br>}</pre>\n<h3>6. Typescript</h3>\n<p>If someone had the audacity to add <a href=\"https://medium.com/javarevisited/7-best-courses-to-learn-typescript-in-depth-58439e1ce729\">TypeScript</a> to the project, you can bypass type checking by using any everywhere.</p>\n<pre>function add(a:any, b:any):any {<br>  return a + b<br>}</pre>\n<h3>7. Use double equal instead of triple\u00a0equal</h3>\n<p>Use == instead of === with the excuse of saving valuable bytes in your production bundle.</p>\n<h3>8. Comment\u00a0Code</h3>\n<p>On top of writing code that is hard to understand, leaving misleading comments that make no sense is a great way to confuse\u00a0others.</p>\n<p>Some rules to\u00a0follow:</p>\n<ul>\n<li>Comments should duplicate the\u00a0code.</li>\n<li>Comments excuse unclear\u00a0code.</li>\n<li><strong>If you can write a clear comment,\u00a0don\u2019t.</strong></li>\n<li>Comments should cause confusion, not dispel\u00a0it.</li>\n<li>Never provide links to the original source of copied\u00a0code.</li>\n<li>Never include links to external references where they will be most\u00a0helpful.</li>\n<li>Never add comments (or tests) when fixing\u00a0bugs.</li>\n<li>Never use comments to mark incomplete implementations.</li>\n</ul>\n<p><a href=\"https://stackoverflow.blog/2021/12/23/best-practices-for-writing-code-comments/\">More rules to\u00a0avoid</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/531/0*Kccm-NECWkzNngVC.png\"></figure><h3>9. Use Props for Shared\u00a0State</h3>\n<p>Passing state around with props is a great way to couple component hierarchy and make refactoring harder.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/479/0*8dnnrIVv0jyaidSk.jpg\"></figure><h3>10. Use State Management for Component State</h3>\n<p>Component state on the other hand should be moved to a global store so everyone can modify\u00a0it.</p>\n<h3>11. Long Component Files</h3>\n<p>Use big and monolithic components with the excuse of having a better view of the component responsibilities and the ability to reuse variables across features.</p>\n<h3>12. No\u00a0Linter</h3>\n<p>A linter can <a href=\"https://www.uplers.com/blog/front-end-linting-tools-for-web-development/\">analyze your code, and detect potential errors, inconsistencies, and deviations from established coding standards</a> which is something that we clearly don't\u00a0want.</p>\n<p>The difference in the two following snippets is apparent:</p>\n<pre>const props=defineProps({<br>elements:Array,<br>counter:{<br>type:Number,<br>default:0,<br>},<br>});<br>const{data,method}=useComposable();<br>const isEmpty=computed(()=&gt;{returnprops.counter===0;});<br><br>watch(props.counter,()=&gt;{console.log(\"Countervaluechanged\");});<br>const emit=defineEmits([\"event-name\"]);<br><br>function emitEvent(){<br>emit(\"event-name\");<br>}<br><br>function getParam(param){<br>return param;<br>}</pre>\n<pre>const props = defineProps({<br>  elements: Array,<br>  counter: {<br>    type: Number,<br>    default: 0,<br>  },<br>});<br><br>const { data, method } = useComposable();<br><br>const isEmpty = computed(() =&gt; {<br>  return props.counter === 0;<br>});<br><br>watch(props.counter, () =&gt; {<br>  console.log(\"Counter value changed\");<br>});<br><br>const emit = defineEmits([\"event-name\"]);<br><br>function emitEvent() {<br>  emit(\"event-name\");<br>}<br><br>function getParam(param) {<br>  return param;<br>}</pre>\n<blockquote>Pro tip: the only acceptable usage of a linting rule is to enfore a file to be longer that a given amount of lines. 1000 is a good starting\u00a0number.</blockquote>\n<h3>13. Use HTML inside Translations</h3>\n<p>Using hardcoded strings is always a good idea. But sometimes using translations that include html elements and classes can be even\u00a0better.</p>\n<p>translation.key.name = Hello &lt;span class=\"red\"&gt;World!&lt;/span&gt;</p>\n<h3>14. Write\u00a0Tests</h3>\n<p>Not writing tests is a good option but having a bad suite can cause even more frustration. As a general guideline, a test should\u00a0be:</p>\n<ul>\n<li>[S]low\u200a\u2014\u200ataking enough time to brew a\u00a0coffee</li>\n<li>[U]nreliable\u200a\u2014\u200aproduce variable\u00a0results</li>\n<li>[C]oupled\u200a\u2014\u200aaffect other\u00a0tests</li>\n<li>[K]nowledgable\u200a\u2014\u200aknow as much as possible about other parts of the application</li>\n</ul>\n<p><a href=\"https://fadamakis.com/8-tips-for-writing-better-unit-tests-8c0a8d8cde16\">More tips</a> to avoid about unit\u00a0tests.</p>\n<h3>15. Always Trust\u00a0Everyone</h3>\n<p>Lastly, <a href=\"https://programmingduck.com/articles/defensive-programming\">defensive programming</a> is for the weak and inexperienced. Why would anyone want to hurt you\u00a0anyway?</p>\n<h3>Conclusion</h3>\n<p>Please don\u2019t hate me and don\u2019t get fired because of this.\u00a0\ud83d\ude05</p>\n<p>If you want to read more terrible advice have a look at <a href=\"https://pvs-studio.com/en/blog/posts/cpp/1053/\">60 terrible tips for a C++ developer</a> which inspired this article. And if you have a piece of evil advice yourself please leave a comment\u00a0below.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*DRMp9f99MXEuPRLOFg327A.gif\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e821e95f5d18\" width=\"1\" height=\"1\" alt=\"\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*lQ0kEv6S8f1VWfaD.jpg\"></figure><p>Medium is full of useful articles and great advice to create robust and maintainable applications. But what If you don't like your colleagues and want to ruin their day? Then worry no more. I\u2019m great at giving bad advice and came up with 15 tips to cause frustration and waste everyone's time.</p>\n<h3>1. Abstraction Layers</h3>\n<p>Use as many abstraction layers as possible\u00a0until:</p>\n<ul>\n<li>The code is difficult to understand and\u00a0debug.</li>\n<li>It is difficult to make changes to the\u00a0code.</li>\n<li>The code is slow or inefficient.</li>\n<li>The code is not reusable.</li>\n</ul>\n<h3>2. Always Request Changes on Pull\u00a0Requests</h3>\n<p>You should always block a pull request during the first review to assert dominance.</p>\n<p>Some ideas for change requests\u00a0are:</p>\n<ul>\n<li>Make a variable name\u00a0longer</li>\n<li>Make a variable name\u00a0shorter</li>\n<li>Rename a variable\u00a0name</li>\n<li>Make code more\u00a0<em>DRY</em>\n</li>\n</ul>\n<h3>3. No Commit\u00a0Messages</h3>\n<p><a href=\"https://cbea.ms/git-commit/\">Good commit messages</a> take time to write. Instead of spending your valuable time writing something like</p>\n<p>[JIRA-1234] build: replace vue-cli with\u00a0vite</p>\n<p>you can use the following command to push your code with an empty commit\u00a0message</p>\n<p>git commit --allow-empty-message -m \"\" &amp;&amp; git push\u00a0--force</p>\n<h3>4. Use Magic\u00a0Numbers</h3>\n<p>Use magic numbers often to indicate that you know <strong><em>exactly</em></strong> what you are\u00a0doing</p>\n<pre>window.scrollTo({<br>  top: 89,<br>  left: 12,<br>  behavior: \"smooth\",<br>});</pre>\n<h3>5. Mix Return Statements</h3>\n<p>Never let them know your next move by mixing the return statements of a\u00a0function</p>\n<pre>function shouldPayTax(income) {<br>  if(income.amount &lt; 20_000) {<br>    return false<br>  }<br>  if(income.amount &gt; 20_000 &amp;&amp; income.country == 'USA') {<br>    return true<br>  }<br>  if(income.country == 'Panama') {<br>    return false<br>  }<br>  if(this.totalWorkingHoursPerWeek &gt; 60) {<br>    return true<br>  }<br>  if(income.amount &gt; 20_000 &amp;&amp; income.isCelebrity == true) {<br>    return false<br>  }<br>  if(income.amount &gt; 20_000) {<br>    return true<br>  }<br>}</pre>\n<h3>6. Typescript</h3>\n<p>If someone had the audacity to add <a href=\"https://medium.com/javarevisited/7-best-courses-to-learn-typescript-in-depth-58439e1ce729\">TypeScript</a> to the project, you can bypass type checking by using any everywhere.</p>\n<pre>function add(a:any, b:any):any {<br>  return a + b<br>}</pre>\n<h3>7. Use double equal instead of triple\u00a0equal</h3>\n<p>Use == instead of === with the excuse of saving valuable bytes in your production bundle.</p>\n<h3>8. Comment\u00a0Code</h3>\n<p>On top of writing code that is hard to understand, leaving misleading comments that make no sense is a great way to confuse\u00a0others.</p>\n<p>Some rules to\u00a0follow:</p>\n<ul>\n<li>Comments should duplicate the\u00a0code.</li>\n<li>Comments excuse unclear\u00a0code.</li>\n<li><strong>If you can write a clear comment,\u00a0don\u2019t.</strong></li>\n<li>Comments should cause confusion, not dispel\u00a0it.</li>\n<li>Never provide links to the original source of copied\u00a0code.</li>\n<li>Never include links to external references where they will be most\u00a0helpful.</li>\n<li>Never add comments (or tests) when fixing\u00a0bugs.</li>\n<li>Never use comments to mark incomplete implementations.</li>\n</ul>\n<p><a href=\"https://stackoverflow.blog/2021/12/23/best-practices-for-writing-code-comments/\">More rules to\u00a0avoid</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/531/0*Kccm-NECWkzNngVC.png\"></figure><h3>9. Use Props for Shared\u00a0State</h3>\n<p>Passing state around with props is a great way to couple component hierarchy and make refactoring harder.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/479/0*8dnnrIVv0jyaidSk.jpg\"></figure><h3>10. Use State Management for Component State</h3>\n<p>Component state on the other hand should be moved to a global store so everyone can modify\u00a0it.</p>\n<h3>11. Long Component Files</h3>\n<p>Use big and monolithic components with the excuse of having a better view of the component responsibilities and the ability to reuse variables across features.</p>\n<h3>12. No\u00a0Linter</h3>\n<p>A linter can <a href=\"https://www.uplers.com/blog/front-end-linting-tools-for-web-development/\">analyze your code, and detect potential errors, inconsistencies, and deviations from established coding standards</a> which is something that we clearly don't\u00a0want.</p>\n<p>The difference in the two following snippets is apparent:</p>\n<pre>const props=defineProps({<br>elements:Array,<br>counter:{<br>type:Number,<br>default:0,<br>},<br>});<br>const{data,method}=useComposable();<br>const isEmpty=computed(()=&gt;{returnprops.counter===0;});<br><br>watch(props.counter,()=&gt;{console.log(\"Countervaluechanged\");});<br>const emit=defineEmits([\"event-name\"]);<br><br>function emitEvent(){<br>emit(\"event-name\");<br>}<br><br>function getParam(param){<br>return param;<br>}</pre>\n<pre>const props = defineProps({<br>  elements: Array,<br>  counter: {<br>    type: Number,<br>    default: 0,<br>  },<br>});<br><br>const { data, method } = useComposable();<br><br>const isEmpty = computed(() =&gt; {<br>  return props.counter === 0;<br>});<br><br>watch(props.counter, () =&gt; {<br>  console.log(\"Counter value changed\");<br>});<br><br>const emit = defineEmits([\"event-name\"]);<br><br>function emitEvent() {<br>  emit(\"event-name\");<br>}<br><br>function getParam(param) {<br>  return param;<br>}</pre>\n<blockquote>Pro tip: the only acceptable usage of a linting rule is to enfore a file to be longer that a given amount of lines. 1000 is a good starting\u00a0number.</blockquote>\n<h3>13. Use HTML inside Translations</h3>\n<p>Using hardcoded strings is always a good idea. But sometimes using translations that include html elements and classes can be even\u00a0better.</p>\n<p>translation.key.name = Hello &lt;span class=\"red\"&gt;World!&lt;/span&gt;</p>\n<h3>14. Write\u00a0Tests</h3>\n<p>Not writing tests is a good option but having a bad suite can cause even more frustration. As a general guideline, a test should\u00a0be:</p>\n<ul>\n<li>[S]low\u200a\u2014\u200ataking enough time to brew a\u00a0coffee</li>\n<li>[U]nreliable\u200a\u2014\u200aproduce variable\u00a0results</li>\n<li>[C]oupled\u200a\u2014\u200aaffect other\u00a0tests</li>\n<li>[K]nowledgable\u200a\u2014\u200aknow as much as possible about other parts of the application</li>\n</ul>\n<p><a href=\"https://fadamakis.com/8-tips-for-writing-better-unit-tests-8c0a8d8cde16\">More tips</a> to avoid about unit\u00a0tests.</p>\n<h3>15. Always Trust\u00a0Everyone</h3>\n<p>Lastly, <a href=\"https://programmingduck.com/articles/defensive-programming\">defensive programming</a> is for the weak and inexperienced. Why would anyone want to hurt you\u00a0anyway?</p>\n<h3>Conclusion</h3>\n<p>Please don\u2019t hate me and don\u2019t get fired because of this.\u00a0\ud83d\ude05</p>\n<p>If you want to read more terrible advice have a look at <a href=\"https://pvs-studio.com/en/blog/posts/cpp/1053/\">60 terrible tips for a C++ developer</a> which inspired this article. And if you have a piece of evil advice yourself please leave a comment\u00a0below.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*DRMp9f99MXEuPRLOFg327A.gif\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e821e95f5d18\" width=\"1\" height=\"1\" alt=\"\">\n",
          "enclosure": {},
          "categories": [
              "front-end-development",
              "funny",
              "javascript",
              "programming",
              "web-development"
          ]
      }
  ]
}